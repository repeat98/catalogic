{"version":3,"file":"841.bundle.js","mappings":"uIACA,MAAMA,EAAkB,CACtBC,KAAM,oBACNC,OAAQ,CACNC,OAEE,kQAWFC,KAEE,sHAKFC,IAEE,gMASAC,EAAwB,IACzBN,EACHE,OAAQ,IACHF,EAAgBE,OAEnBC,OAAQH,EAAgBE,OAAOC,OAAOI,QAAQ,WAAY,cAGxDC,EAAoB,CACxBP,KAAM,oBACNC,OAAQ,CACNC,OAEE,gIAOFC,KAEE,yFAKFC,IAEE,sJ,0CC/DN,MAAMI,EAAa,CACjBR,KAAM,cACNC,OAAQ,CACNC,OAEE,sLASFC,KAEE,qFAKJM,SAAU,CACRP,OAEE,sJAOFC,KAEE,+EAMAO,EAAe,CACnBV,KAAM,cACNC,OAAQ,CACNC,OAEE,uDAIFC,KAEE,qEAKJM,SAAU,CACRP,OAEE,+DAMFC,KAEE,8D,yDC/DN,SAASQ,EAAiBC,EAAUC,GAClC,IAAK,MAAMC,KAAKF,EAASG,WAAY,CACnC,MAAMC,EAAYJ,EAASG,WAAWD,GAChCG,EAAgBJ,EAAcC,GAChCG,GACFD,EAAUE,SAAWF,EAAUE,OAASD,EAAcC,QACtDF,EAAUG,SAAWH,EAAUG,OAASF,EAAcE,QACtDH,EAAUI,WAAaJ,EAAUI,SAAWH,EAAcG,YAE1D,OAAK,aAAaN,qGAEtB,EAGF,SAA8BF,GAC5B,MAAM,QAAES,EAAO,WAAEN,GAAeH,EAC1BU,EAAa,CAAC,EACdC,EAAY,CAAC,EACnB,IAAK,MAAMC,KAAKH,EAAS,CACvB,MAAMI,EAASJ,EAAQG,GACvBF,EAAWG,EAAOC,KAAO,EACzBH,EAAUE,EAAOC,KAAO,CAC1B,CACA,IAAK,MAAMF,KAAKT,EAAY,CAC1B,MAAMC,EAAYD,EAAWS,GAC7BF,EAAWN,EAAUS,OAAOC,OAAQ,OAA2BV,EAAUE,QAAQS,MACnF,CACA,IAAK,MAAMH,KAAKT,EAAY,CAC1B,MAAMC,EAAYD,EAAWS,GAC7BR,EAAUW,SAAWX,EAAUW,OAASL,EAAWN,EAAUS,OAAOC,MACpEV,EAAUY,QAAUZ,EAAUY,MAAQL,EAAUP,EAAUS,OAAOC,MACjEH,EAAUP,EAAUS,OAAOC,OAAQ,OAA2BV,EAAUE,QAAQS,MAClF,CACF,CArBEE,CAAqBjB,EACvB,C,gDCdA,MAAMkB,EAAwB,GAC9BA,EAAsB,IAAcC,WAAQ,EAC5CD,EAAsB,IAAcE,UAAY,CAC9CC,iBAAkB,EAClBC,gBAAiB,GAEnBJ,EAAsB,IAAcK,oBAAsB,CACxDC,aAAc,CACZC,QAAS,QACTC,OAAQ,mBAEVC,YAAa,CACXF,QAAS,QACTC,OAAQ,oBAGZR,EAAsB,IAAcU,uBAAyB,CAC3DJ,aAAc,CACZC,QAAS,QACTC,OAAQ,mBAEVC,YAAa,CACXF,QAAS,QACTC,OAAQ,oBAGZR,EAAsB,IAAcW,aAAe,CACjDR,iBAAkB,EAClBG,aAAc,CACZC,QAAS,QACTC,OAAQ,QAEVC,YAAa,CACXF,QAAS,QACTC,OAAQ,SAGZR,EAAsB,IAAcY,qBAAuB,CACzDT,iBAAkB,EAClBG,aAAc,CACZC,QAAS,YACTC,OAAQ,WAEVC,YAAa,CACXF,QAAS,YACTC,OAAQ,W,iEC3CZ,MAAMK,EAAgB,MAAMA,EAI1B,WAAAC,CAAYC,EAAa,CAAC,GAiBxB,GAfAC,KAAKpB,KAAM,OAAI,gBAKfoB,KAAKC,cAAgB,GACrBD,KAAKE,QAAU,EACfF,KAAKG,QAAS,EACdH,KAAKI,MAAQ,IAAIC,aAAa,GAE9BL,KAAKM,uBAAwB,EAC7BP,EAAa,IAAKF,EAAcU,kBAAmBR,GACnDC,KAAKQ,QAAUT,EAAWS,QAC1BR,KAAKS,MAAQV,EAAWU,MACxBT,KAAKG,OAASJ,EAAWI,OACe,iBAA7BJ,EAAWE,cAA4B,CAChDD,KAAKM,uBAAwB,EAC7B,IAAK,IAAItC,EAAI,EAAGA,EAAI+B,EAAWE,cAAejC,IAC5CgC,KAAKC,cAAcS,KACjB,IAAI,IAAc,CAChBC,MAAOZ,EAAWY,MAClBC,OAAQb,EAAWa,OACnBC,WAAYd,EAAWc,WACvBC,UAAWf,EAAWe,YAI9B,KAAO,CACLd,KAAKC,cAAgB,IAAIF,EAAWE,cAAcc,KAAKC,GAAYA,EAAQC,UAC3E,MAAMC,EAAclB,KAAKmB,aAAaF,OACtCjB,KAAKoB,OAAOF,EAAYP,MAAOO,EAAYN,OAAQM,EAAYG,YACjE,CACArB,KAAKmB,aAAaF,OAAOK,GAAG,SAAUtB,KAAKuB,eAAgBvB,OACvDD,EAAWyB,qBAAuBxB,KAAKQ,WACrCT,EAAWyB,+BAA+B,KAAWzB,EAAWyB,+BAA+B,IACjGxB,KAAKwB,oBAAsBzB,EAAWyB,oBAAoBP,OAE1DjB,KAAKyB,4BAGX,CACA,QAAIC,GACF,MAAMtB,EAAQJ,KAAKI,MAGnB,OAFAA,EAAM,GAAKJ,KAAK2B,WAChBvB,EAAM,GAAKJ,KAAK4B,YACTxB,CACT,CACA,SAAIO,GACF,OAAOX,KAAKmB,aAAaF,OAAON,KAClC,CACA,UAAIC,GACF,OAAOZ,KAAKmB,aAAaF,OAAOL,MAClC,CACA,cAAIe,GACF,OAAO3B,KAAKmB,aAAaF,OAAOU,UAClC,CACA,eAAIC,GACF,OAAO5B,KAAKmB,aAAaF,OAAOW,WAClC,CACA,cAAIf,GACF,OAAOb,KAAKmB,aAAaF,OAAOI,WAClC,CACA,gBAAIF,GACF,OAAOnB,KAAKC,cAAc,EAC5B,CACA,cAAAsB,CAAeN,GACbjB,KAAKoB,OAAOH,EAAON,MAAOM,EAAOL,OAAQK,EAAOI,aAAa,EAC/D,CAOA,yBAAAI,GACOzB,KAAKwB,sBACRxB,KAAKwB,oBAAsB,IAAI,IAAc,CAC3Cb,MAAOX,KAAKW,MACZC,OAAQZ,KAAKY,OACbC,WAAYb,KAAKa,WACjBzC,OAAQ,uBACRyD,qBAAqB,EACrBf,WAAW,EACXgB,cAAe,IAIrB,CACA,MAAAV,CAAOT,EAAOC,EAAQC,EAAab,KAAKa,WAAYkB,GAAmB,GACrE/B,KAAKE,UACLF,KAAKC,cAAc+B,SAAQ,CAACb,EAAcnD,KACpC+D,GAA0B,IAAN/D,GAExBmD,EAAaF,OAAOG,OAAOT,EAAOC,EAAQC,EAAW,IAEnDb,KAAKwB,qBACPxB,KAAKwB,oBAAoBP,OAAOG,OAAOT,EAAOC,EAAQC,EAE1D,CACA,OAAAoB,GACEjC,KAAKmB,aAAaF,OAAOiB,IAAI,SAAUlC,KAAKuB,eAAgBvB,MACxDA,KAAKM,uBACPN,KAAKC,cAAc+B,SAAShB,IAC1BA,EAAQiB,SAAS,IAGjBjC,KAAKwB,sBACPxB,KAAKwB,oBAAoBS,iBAClBjC,KAAKwB,oBAEhB,GAGF3B,EAAcU,eAAiB,CAE7BI,MAAO,EAEPC,OAAQ,EAERC,WAAY,EAEZZ,cAAe,EAEfO,SAAS,EAETC,OAAO,EAEPK,WAAW,EAGXX,QAAQ,GAEV,IAAIgC,EAAetC,C,8HClInB,MAAMuC,EACJ,WAAAtC,CAAYuC,GAEVrC,KAAKsC,aAAe,IAAIC,EAAA,EAExBvC,KAAKwC,SAAW,IAAID,EAAA,EAKpBvC,KAAKyC,qBAAuB,IAAIC,EAAA,EAAa,wBAE7C1C,KAAK2C,iBAAmB,IAAIC,EAAA,EAE5B5C,KAAK6C,kBAAoB,CAAC,EAAG,EAAG,EAAG,GAKnC7C,KAAK8C,iCAAmD,IAAIC,IAE5D/C,KAAKgD,qBAAuCC,OAAOC,OAAO,MAM1DlD,KAAKmD,mBAAqB,GAC1BnD,KAAKoD,UAAYf,EACjBA,EAASgB,aAAaC,eAAetD,KAAM,uBAC7C,CAEA,gBAAAuD,GACEvD,KAAKwD,QAAQD,iBAAiBvD,KAAKyD,aACrC,CASA,WAAAC,EAAY,OACVC,EAAM,MACNC,EAAK,WACLC,EAAU,MACVC,IAEA9D,KAAKmD,mBAAmBY,OAAS,EACjC/D,KAAKU,KACHiD,EACAC,EACAC,EACAC,GAEF9D,KAAKsC,aAAa0B,SAAShE,KAAKwC,UAChCxC,KAAKiE,iBAAmBjE,KAAKyD,aAC7BzD,KAAKkE,kBCtET,SAA6BT,GAC3B,MAAMU,EAAWV,EAAatC,aAAaF,OAAOkD,SAClD,OAAOC,WAAWC,mBAAqBF,aAAoBE,mBAAqBC,SAASC,KAAKC,SAASL,EACzG,CDmE6BM,CAAoBzE,KAAKiE,kBAClDjE,KAAKwD,QAAQkB,YAAY1E,KAAKiE,iBAChC,CACA,UAAAU,GACE3E,KAAKwD,QAAQmB,aAAa3E,KAAKiE,iBACjC,CAaA,IAAAW,CAAKC,EAAejB,GAAQ,EAAMC,EAAYC,GAC5C,MAAML,EAAezD,KAAK8E,gBAAgBD,GACpCE,EAAY/E,KAAKyD,eAAiBA,EACxCzD,KAAKyD,aAAeA,EACpBzD,KAAK6E,cAAgBA,EACrB,MAAMG,EAAkBhF,KAAKiF,mBAAmBxB,GAC5CA,EAAa9B,aAAeqD,EAAgBrE,OAAS8C,EAAa7B,cAAgBoD,EAAgBpE,SACpGZ,KAAKwD,QAAQ0B,sBAAsBzB,GACnCuB,EAAgBrE,MAAQ8C,EAAa9B,WACrCqD,EAAgBpE,OAAS6C,EAAa7B,aAExC,MAAMX,EAASwC,EAAatC,aACtBqB,EAAWxC,KAAKwC,SAChBb,EAAaV,EAAOU,WACpBC,EAAcX,EAAOW,YAI3B,IAHKkC,GAASe,aAAyBM,EAAA,IACrCrB,EAAQe,EAAcf,OAEpBA,EAAO,CACT,MAAMjD,EAAaI,EAAOI,YAC1BmB,EAAS4C,EAAItB,EAAMsB,EAAIvE,EAAa,GAAM,EAC1C2B,EAAS6C,EAAIvB,EAAMuB,EAAIxE,EAAa,GAAM,EAC1C2B,EAAS7B,MAAQmD,EAAMnD,MAAQE,EAAa,GAAM,EAClD2B,EAAS5B,OAASkD,EAAMlD,OAASC,EAAa,GAAM,CACtD,MACE2B,EAAS4C,EAAI,EACb5C,EAAS6C,EAAI,EACb7C,EAAS7B,MAAQgB,EACjBa,EAAS5B,OAASgB,EAcpB,OElIJ,SAA6B0D,EAAIF,EAAGC,EAAG1E,EAAOC,EAAQ2E,GACpD,MAAMC,EAAOD,EAAQ,GAAK,EAC1BD,EAAGG,WACHH,EAAGI,EAAI,EAAI/E,EAAQ,EACnB2E,EAAGK,EAAIH,GAAQ,EAAI5E,EAAS,GAC5B0E,EAAGM,IAAM,EFmHL,EEnHaN,EAAGI,EACpBJ,EAAGO,IAAML,EFmHL,EEnHgBF,EAAGK,CAEzB,CF8GIG,CACE9F,KAAK2C,iBACL,EACA,EACAH,EAAS7B,MAAQM,EAAOJ,WACxB2B,EAAS5B,OAASK,EAAOJ,YACxB4C,EAAatD,QAEhBH,KAAKwD,QAAQuC,gBAAgBtC,EAAcG,EAAOC,EAAYrB,GAC1DuC,GACF/E,KAAKyC,qBAAqBuD,KAAKvC,GAE1BA,CACT,CACA,KAAAG,CAAMD,EAAQC,EAAQ,IAAMqC,IAAKpC,GAC1BD,IAEDD,IACFA,EAAS3D,KAAK8E,gBAAgBnB,IAEhC3D,KAAKwD,QAAQI,MACXD,GAAU3D,KAAKyD,aACfG,EACAC,EACA7D,KAAKwC,UAET,CACA,aAAA0D,GACElG,KAAKgD,qBAAuCC,OAAOC,OAAO,KAC5D,CAQA,IAAAxC,CAAKmE,EAAejB,EAAQ,IAAMqC,IAAKpC,EAAYC,GACjD,MAAML,EAAezD,KAAK4E,KAAKC,EAAejB,EAAOC,EAAYC,GAKjE,OAJA9D,KAAKmD,mBAAmBzC,KAAK,CAC3B+C,eACAK,UAEKL,CACT,CAEA,GAAA0C,GACEnG,KAAKmD,mBAAmBgD,MACxB,MAAMC,EAA0BpG,KAAKmD,mBAAmBnD,KAAKmD,mBAAmBY,OAAS,GACzF/D,KAAK4E,KAAKwB,EAAwB3C,cAAc,EAAO,KAAM2C,EAAwBtC,MACvF,CAQA,eAAAgB,CAAgBD,GAId,OAHIA,EAAcwB,YAChBxB,EAAgBA,EAAc5D,QAEzBjB,KAAK8C,iCAAiCwD,IAAIzB,IAAkB7E,KAAKuG,kBAAkB1B,EAC5F,CAwCA,aAAA2B,CAAcC,EAA4BC,EAAoBC,EAAWjF,EAAMkF,GACzED,EAAUvB,EAAI,IAChB1D,EAAKf,OAASgG,EAAUvB,EACxBwB,EAAWxB,GAAKuB,EAAUvB,EAC1BuB,EAAUvB,EAAI,GAEZuB,EAAUtB,EAAI,IAChB3D,EAAKd,QAAU+F,EAAUtB,EACzBuB,EAAWvB,GAAKsB,EAAUtB,EAC1BsB,EAAUtB,EAAI,GAEhB,MAAM,WAAE1D,EAAU,YAAEC,GAAgB6E,EAGpC,OAFA/E,EAAKf,MAAQkG,KAAKC,IAAIpF,EAAKf,MAAOgB,EAAagF,EAAUvB,GACzD1D,EAAKd,OAASiG,KAAKC,IAAIpF,EAAKd,OAAQgB,EAAc+E,EAAUtB,GACrDrF,KAAKwD,QAAQgD,cAClBC,EACAC,EACAC,EACAjF,EACAkF,EAEJ,CAKA,kBAAAG,GACO/G,KAAKyD,aAAajD,UACrBR,KAAKyD,aAAajD,SAAU,EAC5BR,KAAKwD,QAAQuC,gBAAgB/F,KAAKyD,cAAc,EAAO,KAAMzD,KAAKwC,UAEtE,CAEA,OAAAP,GACEjC,KAAKoD,UAAY,KACjBpD,KAAK8C,iCAAiCd,SAAQ,CAACyB,EAAcuD,KACvDvD,IAAiBuD,GACnBvD,EAAaxB,SACf,IAEFjC,KAAK8C,iCAAiCc,QACtC5D,KAAKgD,qBAAuCC,OAAOC,OAAO,KAC5D,CACA,iBAAAqD,CAAkB1B,GAChB,IAAIpB,EAAe,KAwBnB,OAvBIwD,EAAA,EAAaC,KAAKrC,KACpBA,GAAgB,EAAAsC,EAAA,GAAiBtC,GAAe5D,QAE9C4D,aAAyB1C,EAAA,EAC3BsB,EAAeoB,EACNA,aAAyBuC,EAAA,IAClC3D,EAAe,IAAItB,EAAA,EAAa,CAC9BlC,cAAe,CAAC4E,KAEdoC,EAAA,EAAaC,KAAKrC,EAAc5D,OAAOkD,YACzCV,EAAatD,QAAS,GAExB0E,EAAcwC,KAAK,WAAW,KAC5B5D,EAAaxB,UACbjC,KAAK8C,iCAAiCwE,OAAOzC,GAC7C,MAAMG,EAAkBhF,KAAKgD,qBAAqBS,EAAa7E,KAC3DoG,IACFhF,KAAKgD,qBAAqBS,EAAa7E,KAAO,KAC9CoB,KAAKwD,QAAQ+D,uBAAuBvC,GACtC,KAGJhF,KAAK8C,iCAAiC0E,IAAI3C,EAAepB,GAClDA,CACT,CACA,kBAAAwB,CAAmBxB,GACjB,OAAOzD,KAAKgD,qBAAqBS,EAAa7E,OAASoB,KAAKgD,qBAAqBS,EAAa7E,KAAOoB,KAAKwD,QAAQiE,oBAAoBhE,GACxI,CACA,UAAAiE,GACE1H,KAAKyD,aAAe,KACpBzD,KAAK6E,cAAgB,IACvB,E,kCGzSF,MAAM8C,EAAe,CACnBC,OAAQ,EACRC,IAAK,EACLC,SAAU,EACVC,OAAQ,EACRC,QAAS,EACTC,MAAO,EACP,aAAc,EACd,UAAW,EACX,aAAc,EACdnB,IAAK,EACLoB,IAAK,IAQDC,EAAS,MAAMA,EACnB,WAAArI,GACEE,KAAKoI,KAAO,EACZpI,KAAKqI,UAAY,SACjBrI,KAAKsI,cAAgB,EACrBtI,KAAKuI,OAAQ,EACbvI,KAAKwI,WAAY,CACnB,CAKA,SAAID,GACF,SAAsB,EAAZvI,KAAKoI,KACjB,CACA,SAAIG,CAAME,MACW,EAAZzI,KAAKoI,QAAuBK,IACjCzI,KAAKoI,MAAQ,EAEjB,CAKA,WAAIM,GACF,SAAsB,EAAZ1I,KAAKoI,KACjB,CACA,WAAIM,CAAQD,MACS,EAAZzI,KAAKoI,QAAwBK,IAClCzI,KAAKoI,MAAQ,EAEjB,CAEA,YAAIO,CAASF,GACG,SAAVA,GAIJzI,KAAK4I,SAAU,EACf5I,KAAK6I,mBAA+B,UAAVJ,GAJxBzI,KAAK4I,SAAU,CAKnB,CACA,YAAID,GACF,OAAK3I,KAAK4I,QAGH5I,KAAK6I,mBAAqB,QAAU,OAFlC,MAGX,CAKA,WAAID,GACF,SAAsB,EAAZ5I,KAAKoI,KACjB,CACA,WAAIQ,CAAQH,MACS,EAAZzI,KAAKoI,QAAyBK,IACnCzI,KAAKoI,MAAQ,EAEjB,CAKA,aAAIU,GACF,SAAsB,EAAZ9I,KAAKoI,KACjB,CACA,aAAIU,CAAUL,MACO,EAAZzI,KAAKoI,QAA4BK,IACtCzI,KAAKoI,MAAQ,EAEjB,CAKA,aAAII,GACF,SAAsB,GAAZxI,KAAKoI,KACjB,CACA,aAAII,CAAUC,MACO,GAAZzI,KAAKoI,QAA4BK,IACtCzI,KAAKoI,MAAQ,GAEjB,CAKA,sBAAIS,GACF,SAAsB,GAAZ7I,KAAKoI,KACjB,CACA,sBAAIS,CAAmBJ,MACF,GAAZzI,KAAKoI,QAAyBK,IACnCzI,KAAKoI,MAAQ,GAEjB,CAMA,aAAIC,GACF,OAAOrI,KAAK+I,UACd,CACA,aAAIV,CAAUI,GACZzI,KAAKuI,MAAkB,SAAVE,EACbzI,KAAK+I,WAAaN,EAClBzI,KAAKgJ,aAAerB,EAAac,IAAU,CAC7C,CAKA,iBAAIH,GACF,OAAOtI,KAAKiJ,cACd,CACA,iBAAIX,CAAcG,GAChBzI,KAAK0I,UAAYD,EACjBzI,KAAKiJ,eAAiBR,CACxB,CACA,QAAAS,GACE,MAAO,iCAAiClJ,KAAKqI,gCAAgCrI,KAAK6I,8BAA8B7I,KAAK4I,qBAAqB5I,KAAKwI,2BAA2BxI,KAAKsI,gBACjL,CAKA,YAAOa,GACL,MAAMC,EAAQ,IAAIjB,EAGlB,OAFAiB,EAAMN,WAAY,EAClBM,EAAMb,OAAQ,EACPa,CACT,GAEFjB,EAAOkB,UAAYlB,EAAOgB,QAC1B,IAAIG,EAAQnB,C,0DCvJZ,MAAMoB,EACJ,WAAAzJ,CAAYuC,GACVrC,KAAKoD,UAAYf,CACnB,CACA,gBAAAmH,GACA,CACA,iBAAAC,GACA,CACA,kBAAAC,GACE,OAAO,CACT,CACA,aAAAC,CAAcC,EAAWC,GACvB7J,KAAKoD,UAAU0G,YAAYC,MAAMC,MAAMH,GACvCA,EAAehC,IAAI+B,EACrB,CACA,OAAAK,CAAQL,GACDA,EAAUM,cAEfN,EAAUO,OAAOnK,KAAKoD,UACxB,CACA,OAAAnB,GACEjC,KAAKoD,UAAY,IACnB,EAEFmG,EAAiBa,UAAY,CAC3BC,KAAM,CACJ,KAAcC,WACd,KAAcC,YACd,KAAcC,aAEhBtN,KAAM,gB,kCChCR,SAASuN,EAAoBC,EAAarI,GACxC,MAAMwH,EAAiBa,EAAYb,eAC7Bc,EAAed,EAAec,aACpC,IAAK,IAAI3M,EAAI,EAAGA,EAAI6L,EAAee,gBAAiB5M,IAAK,CACvD,MAAM6M,EAAcF,EAAa3M,GACjCqE,EAASwI,EAAYC,cAAcb,QAAQY,EAC7C,CACF,CCDA,MAAME,EAAa,IAAInI,EAAA,EACvB,MAAMoI,EACJ,WAAAlL,CAAYuC,GACVrC,KAAKoD,UAAYf,CACnB,CACA,cAAA4I,CAAeP,EAAab,GACtBa,EAAYQ,kBACdlL,KAAKmL,6BAA6BT,EAAab,GAE/C7J,KAAKoL,qBAAqBV,EAAab,EAE3C,CACA,OAAAI,CAAQS,GACDA,EAAYR,eAEbQ,EAAYQ,kBACdlL,KAAKqL,uBAAuBX,GAE5B1K,KAAKsL,eAAeZ,GAExB,CACA,OAAAzI,GACEjC,KAAKoD,UAAY,IACnB,CACA,oBAAAgI,CAAqBV,EAAab,GAChC7J,KAAKoD,UAAU0G,YAAYC,MAAMC,MAAMH,GACnCa,EAAYa,wBACd,IAAQC,OAAOd,EAAYa,uBAC3Bb,EAAYa,sBAAwB,MAEtC1B,EAAehC,IAAI6C,EACrB,CACA,4BAAAS,CAA6BT,EAAab,GACxC,MAAM4B,EAAuBf,EAAYa,wBAA0Bb,EAAYa,sBAAwB,IAAQjF,IAAIoF,EAAA,IACnHD,EAAqBE,WAAajB,EAAYkB,KAC9CH,EAAqBI,UAAYnB,EAAYkB,KAAKE,uBAClDL,EAAqBzK,QAAU0J,EAAY1J,QAC3CyK,EAAqBM,OAASrB,EAAYsB,eAC1CnC,EAAehC,IAAI6C,GACnB1K,KAAKoD,UAAU0G,YAAYC,MAAMkC,WAAWR,EAAsB5B,EACpE,CACA,sBAAAwB,CAAuBX,GACrB,GAAIA,EAAYwB,mBAAoB,CAClCxB,EAAYwB,oBAAqB,EACjC,MAAMC,EAAuBpB,EAAWtF,WAAW2G,WAChD1B,EAAYsB,eAAe5G,GAC3BsF,EAAYsB,eAAe3G,GAE9BrF,KAAKoD,UAAUK,aAAa/C,KAAKgK,EAAY1J,SAAS,EAAM,KAAM0J,EAAY1J,QAAQ8C,OACtF9D,KAAKoD,UAAUiJ,eAAe3L,KAAK,CACjCyL,uBACAG,WAAY,aAEd7B,EAAoBC,EAAa1K,KAAKoD,UAAU0G,aAChD9J,KAAKoD,UAAUK,aAAaF,mBAC5BvD,KAAKoD,UAAUK,aAAa0C,MAC5BnG,KAAKoD,UAAUiJ,eAAelG,KAChC,CACAuE,EAAYa,sBAAsBgB,SAASC,cAAc9B,EAAYa,uBACrEb,EAAYa,sBAAsBgB,SAASzO,SAASS,QAAQ,GAAGkO,QACjE,CACA,cAAAnB,CAAeZ,GACb1K,KAAKoD,UAAUiJ,eAAe3L,KAAK,CACjCyL,qBAAsBzB,EAAYgC,8BAClCJ,WAAY5B,EAAYiC,kBAE1BlC,EAAoBC,EAAa1K,KAAKoD,UAAU0G,aAChD9J,KAAKoD,UAAUiJ,eAAelG,KAChC,EAEF6E,EAAgBZ,UAAY,CAC1BC,KAAM,CACJ,KAAcC,WACd,KAAcC,YACd,KAAcC,aAEhBtN,KAAM,e,wBClFR,SAAS0P,EAAUC,EAAMC,GACvBA,IAAUA,EAAQ,GAClB,IAAK,IAAIpO,EAAIoO,EAAOpO,EAAImO,EAAK9I,QACvB8I,EAAKnO,GAD0BA,IAEjCmO,EAAKnO,GAAK,IAKhB,C,uBCLA,MAAMqO,EAAgB,IAAIC,EAAA,GACpBC,EAA6B,KAAiB,KAAe,IACnE,SAASC,EAA4BxC,EAAayC,GAA0B,IAwB5E,SAAoCzC,GAClC,MAAMkB,EAAOlB,EAAYkB,KACzB,IAAIwB,EACJ,GAAI1C,EAAY2C,kBAAmB,CACjC,MAAMA,EAAoB3C,EAAY2C,kBACtC3C,EAAY4C,eAAeC,WACzB3B,EAAKE,uBACLuB,EAAkBC,gBAEpB5C,EAAY4B,YAAa,EAAAkB,EAAA,GACvB5B,EAAK6B,WACLJ,EAAkBf,YAEpBc,EAAaxB,EAAK8B,WAAaL,EAAkBD,UACnD,MACE1C,EAAY4C,eAAetJ,SAAS4H,EAAK+B,gBACzCjD,EAAY4B,WAAaV,EAAKgC,WAC9BR,EAAaxB,EAAKiC,WAEpBT,EAAaA,EAAa,EAAI,EAAIA,EAAa,EAAI,EAAIA,EACvD1C,EAAY0C,WAAaA,EACzB1C,EAAYiC,gBAAkBjC,EAAY4B,YAA4B,IAAbc,GAAyB,GACpF,CA7CEU,CAA2BpD,GAC3B,MAAMqD,EAAmBrD,EAAYqD,iBAC/BC,EAAatD,EAAYsD,aAC/B,IAAK,MAAMtP,KAAKqP,EAAkB,CAChC,MAAME,EAAmBC,OAAOxP,GAC1ByP,EAAkBJ,EAAiBrP,GACnCmO,EAAOsB,EAAgBtB,KACvBC,EAAQqB,EAAgBrB,MAC9B,IAAK,IAAI9O,EAAI,EAAGA,EAAI8O,EAAO9O,IAAK,CAC9B,MAAMoQ,EAAQvB,EAAK7O,GACfoQ,EAAMC,oBAAsB3D,GAAe0D,EAAME,2BAA6BL,GAChFM,EAA2BH,EAAOJ,EAAY,EAElD,CACApB,EAAUC,EAAMC,GAChBqB,EAAgBrB,MAAQ,CAC1B,CACA,GAAIK,EACF,IAAK,IAAInP,EAAI,EAAGA,EAAI0M,EAAY8D,oBAAoBzK,OAAQ/F,IAC1DkP,EAA4BxC,EAAY8D,oBAAoBxQ,GAAImP,EAGtE,CAwBA,SAASoB,EAA2B3E,EAAWoE,EAAYS,GACzD,GAAIT,IAAepE,EAAUoE,WAC3B,OACFpE,EAAUoE,WAAaA,EACvBpE,EAAU7E,WAAY,EACtB,MAAM4I,EAAiB/D,EAAU+D,eACjC/D,EAAU8E,uBACV,MAAMC,EAAS/E,EAAU+E,OAiBzB,GAhBIA,IAAWA,EAAOjE,aACpB+D,GAAe7E,EAAUgF,aACzBhF,EAAUkC,uBAAuByB,WAC/BI,EACAgB,EAAO7C,wBAEL2C,EAAcxB,GAChB4B,EAA2BjF,EAAW+E,EAAQF,KAGhDA,EAAc7E,EAAUgF,aACxBhF,EAAUkC,uBAAuB9H,SAAS2J,GACtCc,EAAcxB,GAChB4B,EAA2BjF,EAAWmD,EAAe0B,KAGpD7E,EAAUc,YAAa,CAC1B,MAAMoE,EAAWlF,EAAUkF,SACrB/K,EAAS+K,EAAS/K,OACxB,IAAK,IAAI/F,EAAI,EAAGA,EAAI+F,EAAQ/F,IAC1BuQ,EAA2BO,EAAS9Q,GAAIgQ,EAAYS,GAEtD,MAAM/D,EAAcd,EAAUyE,kBACxB1C,EAAa/B,EACf+B,EAAWb,eAAiBJ,EAAYqE,oBAC1CrE,EAAYlB,iBAAiBmC,EAEjC,CACF,CACA,SAASkD,EAA2BjF,EAAW+E,EAAQF,GACrD,GAAIA,EAAc,KAAc,CAC9B7E,EAAU6D,YAAa,EAAAD,EAAA,GACrB5D,EAAUgE,WACVe,EAAOlB,YAET,IAAIC,EAAa9D,EAAUiE,WAAac,EAAOjB,WAC/CA,EAAaA,EAAa,EAAI,EAAIA,EAAa,EAAI,EAAIA,EACvD9D,EAAU8D,WAAaA,EACvB9D,EAAUoF,gBAAkBpF,EAAU6D,YAA4B,IAAbC,GAAyB,GAChF,CACIe,EAAc,MAChB7E,EAAUqF,eAA8C,YAA7BrF,EAAUsF,eAA+BP,EAAOM,eAAiBrF,EAAUsF,gBAEpGT,EAAc,OAChB7E,EAAUuF,oBAAsBvF,EAAUwF,mBAAqBT,EAAOQ,qBAExEvF,EAAUgF,aAAe,CAC3B,CCnGA,MAAM,EAAa,IAAIhM,EAAA,EACvB,MAAMyM,EACJ,WAAAvP,CAAYuC,GACVrC,KAAKoD,UAAYf,CACnB,CACA,MAAA8H,EAAO,UAAEP,EAAS,UAAEiC,IAClB,MAAM8C,EAAS/E,EAAU+E,OACnBtB,EAAoBzD,EAAUc,YAAY2C,kBAChDzD,EAAU+E,OAAS,KACnB/E,EAAUc,YAAY2C,kBAAoB,KAC1C,MAAMhL,EAAWrC,KAAKoD,UACtB,IAAIkM,EAAyB,EACzBzD,IACFyD,EAAyBA,EAAuBtL,SAAS4F,EAAUc,YAAYiD,gBAC/E/D,EAAUc,YAAYiD,eAAe3J,SAAS6H,IAEhD,MAAM/B,EAAczH,EAASyH,YAC7B9J,KAAKuP,0BAA0B3F,EAAUc,YAAa,MACtD1K,KAAKwP,oBAAoB5F,EAAUc,aACnCrI,EAASgK,eAAevN,MAAM,CAC5BqN,qBAAsBN,EAAYjC,EAAUc,YAAYiD,eAAiB/D,EAAUc,YAAY4C,eAC/FhB,WAAY1C,EAAUc,YAAYiC,kBAEpClC,EAAoBb,EAAUc,YAAaZ,GACvCA,EAAY2F,cACd3F,EAAY2F,aAAaC,YAEvB7D,GACFjC,EAAUc,YAAYiD,eAAe3J,SAASsL,GAEhD1F,EAAU+E,OAASA,EACnB/E,EAAUc,YAAY2C,kBAAoBA,CAC5C,CACA,OAAApL,GACEjC,KAAKoD,UAAY,IACnB,CACA,yBAAAmM,CAA0B7E,EAAaiF,GACrC,GAAIjF,EAAYQ,kBAAmB,CACjC,IAAKR,EAAYkF,mBACf,OACFD,EAAwBjF,CAC1B,CACAA,EAAYmF,iCAAmCF,EAC/C,IAAK,IAAI3R,EAAI0M,EAAY8D,oBAAoBzK,OAAS,EAAG/F,GAAK,EAAGA,IAC/DgC,KAAKuP,0BAA0B7E,EAAY8D,oBAAoBxQ,GAAI2R,GAGrE,GADAjF,EAAYoF,qBACRpF,EAAYQ,mBACd,GAAIR,EAAYwB,mBAAoB,CAClC,MAAMH,EAASrB,EAAYkB,KAAKmE,iBAChChE,EAAOiE,OACP,MAAMC,EAAcvF,EAAY1J,QAC5B0J,EAAY1J,SACdkP,EAAA,EAAYC,cAAczF,EAAY1J,SAExC,MAAMqB,EAAWrC,KAAKoD,UAChBvC,EAAa6J,EAAY0F,eAAevP,YAAcwB,EAASgO,KAAKxP,WACpEC,EAAY4J,EAAY0F,eAAetP,WAAauB,EAASgO,KAAKvP,UACxE4J,EAAY1J,QAAUkP,EAAA,EAAYI,kBAChCvE,EAAOpL,MACPoL,EAAOnL,OACPC,EACAC,GAEF4J,EAAYsB,iBAAmBtB,EAAYsB,eAAiB,IAAIuE,EAAA,GAChE7F,EAAYsB,eAAehI,SAAS+H,GAChCkE,IAAgBvF,EAAY1J,SAC1B0J,EAAY2C,oBACd3C,EAAY2C,kBAAkB0B,oBAAqB,EAGzD,OACSrE,EAAY1J,UACrBkP,EAAA,EAAYC,cAAczF,EAAY1J,SACtC0J,EAAY1J,QAAU,KAE1B,CACA,mBAAAwO,CAAoB9E,GAClB,MAAMrI,EAAWrC,KAAKoD,UAChB0G,EAAczH,EAASyH,YAiB7B,GAhBAY,EAAY8F,YAAYnO,GACxBqI,EAAYb,eAAeC,YAAcA,EACpCY,EAAYqE,mBAGfnC,EAAUlC,EAAY+F,4BAA4B5D,KAAM,GC9F9D,SAA6BnC,EAAaZ,GACxC,MAAM,KAAE+C,EAAI,MAAEC,GAAUpC,EAAY+F,4BACpC,IAAIC,GAAkB,EACtB,IAAK,IAAI1S,EAAI,EAAGA,EAAI8O,EAAO9O,IAAK,CAC9B,MAAM4L,EAAYiD,EAAK7O,GAIvB,GADA0S,EADa5G,EADMF,EACiBkB,cACbpB,mBAAmBE,GACtC8G,EACF,KAEJ,CACAhG,EAAYqE,mBAAqB2B,CAEnC,CD8EMC,CAAoBjG,EAAaZ,GAInCoD,EAA4BxC,GACxBA,EAAYqE,oBACdrE,EAAYqE,oBAAqB,EACjC/O,KAAK4Q,mBAAmBlG,EAAarI,IAErCrC,KAAK6Q,mBAAmBnG,GAE1BA,EAAY+F,4BAA4B3D,MAAQ,EAChDzK,EAASyH,YAAYC,MAAM+G,OAAOpG,EAAYb,iBAC1Ca,EAAYQ,mBAAsBR,EAAYwB,mBAElD,IAAK,IAAIlO,EAAI,EAAGA,EAAI0M,EAAY8D,oBAAoBzK,OAAQ/F,IAC1DgC,KAAKwP,oBAAoB9E,EAAY8D,oBAAoBxQ,GAE7D,CACA,kBAAA6S,CAAmBnG,GACjB,MAAM,KAAEmC,EAAI,MAAEC,GAAUpC,EAAY+F,4BACpC,IAAK,IAAIzS,EAAI,EAAGA,EAAI8O,EAAO9O,IAAK,CAC9B,MAAM4L,EAAYiD,EAAK7O,GACnB4L,EAAUmH,eACZrG,EAAYlB,iBAAiBI,EAEjC,CACAgD,EAAUC,EAAMC,EAClB,CACA,kBAAA8D,CAAmBlG,EAAasG,GAC9B,MAAMpF,EAAOlB,EAAYkB,KACnB/B,EAAiBa,EAAYb,eACnCA,EAAeoH,QACf,MAAM5O,EAAW2O,EAAgBlH,YAAckH,EAAkBA,EAAgBjH,MAAM1H,SACjFyH,EAAczH,EAASyH,YAC7BA,EAAYC,MAAMmH,WAAWrH,GAC7BC,EAAYzB,UAAU6I,aACtBpH,EAAYqH,UAAUD,aAClBtF,EAAKwF,kBACPxF,EAAKyF,eAEPzF,EAAK0F,8BAA8BzH,EAAgBxH,EAAU,MAC7DyH,EAAYC,MAAMwH,SAAS1H,GAC3BC,EAAYzB,UAAUkJ,SAAS1H,EACjC,EAGFwF,EAAkBjF,UAAY,CAC5BC,KAAM,CACJ,KAAcmH,YACd,KAAcC,aACd,KAAcC,cAEhBxU,KAAM,eE7IR,MAAMyU,EACJ,WAAA7R,CAAYuC,GACVrC,KAAK4R,eAAiC3O,OAAOC,OAAO,MACpDlD,KAAK6R,wBAA0B7R,KAAKyJ,kBAAkB7E,KAAK5E,MAC3DA,KAAKoD,UAAYf,EACjBrC,KAAKoD,UAAUC,aAAaC,eAAetD,KAAM,iBACnD,CACA,aAAA2J,CAAcmI,EAAQjI,GACpB,MAAMkI,EAAY/R,KAAKgS,cAAcF,GACjCA,EAAOf,eACT/Q,KAAKiS,uBAAuBH,EAAQC,GACtC/R,KAAKoD,UAAU0G,YAAYC,MAAMkC,WAAW8F,EAAWlI,EACzD,CACA,gBAAAL,CAAiBsI,GACf,MAAMC,EAAY/R,KAAK4R,eAAeE,EAAOlT,KACzCkT,EAAOf,eACT/Q,KAAKiS,uBAAuBH,EAAQC,GACtCA,EAAUxF,SAASC,cAAcuF,EACnC,CACA,kBAAArI,CAAmBoI,GACjB,MAAMC,EAAY/R,KAAKgS,cAAcF,GACrC,OAAQC,EAAUxF,SAAS2F,sBACzBH,EACAD,EAAOK,SAEX,CACA,iBAAA1I,CAAkBqI,GAChB,MAAMM,EAAkBpS,KAAK4R,eAAeE,EAAOlT,KACnD,IAAQ4M,OAAO4G,GACfpS,KAAK4R,eAAeE,EAAOlT,KAAO,KAClCkT,EAAO5P,IAAI,YAAalC,KAAK6R,wBAC/B,CACA,sBAAAI,CAAuBH,EAAQM,GAC7BA,EAAgBrG,OAAS+F,EAAOO,aAChCD,EAAgBpR,QAAU8Q,EAAOK,QACnC,CACA,aAAAH,CAAcF,GACZ,OAAO9R,KAAK4R,eAAeE,EAAOlT,MAAQoB,KAAKsS,eAAeR,EAChE,CACA,cAAAQ,CAAeR,GACb,MAAMM,EAAkB,IAAQ9L,IAAIoF,EAAA,GAQpC,OAPA0G,EAAgBzG,WAAamG,EAC7BM,EAAgBvG,UAAYiG,EAAOS,eACnCH,EAAgBpR,QAAU8Q,EAAOK,SACjCC,EAAgBrG,OAAS+F,EAAOO,aAChCD,EAAgBI,YAAcxS,KAAKoD,UAAUqP,aAAeX,EAAOW,aACnEzS,KAAK4R,eAAeE,EAAOlT,KAAOwT,EAClCN,EAAOxQ,GAAG,YAAatB,KAAK6R,yBACrBO,CACT,CACA,OAAAnQ,GACE,IAAK,MAAMjE,KAAKgC,KAAK4R,eACnB,IAAQpG,OAAOxL,KAAK4R,eAAe5T,IAErCgC,KAAK4R,eAAiB,KACtB5R,KAAKoD,UAAY,IACnB,EAGFuO,EAAWvH,UAAY,CACrBC,KAAM,CACJ,KAAcC,WACd,KAAcC,YACd,KAAcC,aAEhBtN,KAAM,U,kCCjER,MAAMwV,EAAe,MAAMA,EACzB,WAAA5S,CAAYuC,EAAUmB,GACpBxD,KAAKoJ,MAAQE,EAAA,EAAMH,QACnBnJ,KAAK2S,0BAA4C1P,OAAOC,OAAO,MAE/DlD,KAAK4S,eAAiC3P,OAAOC,OAAO,MACpDlD,KAAKqC,SAAWA,EAChBrC,KAAK6S,SAAWrP,EAChBxD,KAAK6S,SAASC,OAAO9S,KACvB,CACA,iBAAO+S,CAAW7V,GAChB,OAAO,IAAI8C,KAAKgT,mBAAmB9V,EACrC,CACA,UAAAgU,CAAWrH,GACT,IAAIoJ,EAAWjT,KAAK2S,0BAA0B9I,EAAejL,KACxDqU,IACHA,EAAWjT,KAAK2S,0BAA0B9I,EAAejL,KAAuBqE,OAAOC,OAAO,MAC9F+P,EAASC,UAAYD,EAASC,QAAU,IAAIC,EAAA,IAE9CnT,KAAK4S,eAAiBK,EACtBjT,KAAKoT,aAAepT,KAAK4S,eAAeM,QACxC,IAAK,MAAMlV,KAAKgC,KAAK4S,eACnB5S,KAAK4S,eAAe5U,GAAGqV,OAE3B,CACA,UAAApH,CAAWqH,EAAiBzJ,GAC1B,GAAI7J,KAAKoT,aAAalW,OAASoW,EAAgBC,YAAa,CAC1DvT,KAAKoT,aAAapJ,MAAMH,GACxB,IAAIE,EAAQ/J,KAAK4S,eAAeU,EAAgBC,aAC3CxJ,IACHA,EAAQ/J,KAAK4S,eAAeU,EAAgBC,aAAeb,EAAaK,WAAWO,EAAgBC,aACnGxJ,EAAMsJ,SAERrT,KAAKoT,aAAerJ,CACtB,CACA/J,KAAKoT,aAAavL,IAAIyL,EACxB,CACA,MAAMzJ,GACJ7J,KAAKoT,aAAapJ,MAAMH,EAC1B,CACA,QAAA0H,CAAS1H,GACP7J,KAAKoT,aAAapJ,MAAMH,GACxB,MAAM2J,EAAUxT,KAAK4S,eACrB,IAAK,MAAM5U,KAAKwV,EAAS,CACvB,MAAMzJ,EAAQyJ,EAAQxV,GAChBF,EAAWiM,EAAMjM,SACvBA,EAAS2V,YAAYC,gBAAgB3J,EAAM0J,YAAa1J,EAAM4J,WAAW,GACzE7V,EAASS,QAAQ,GAAGmV,gBAAgB3J,EAAM6J,gBAAgBC,YAAa9J,EAAM+J,eAAe,EAC9F,CACF,CACA,MAAAhD,CAAOjH,GACL,MAAMoJ,EAAWjT,KAAK2S,0BAA0B9I,EAAejL,KAC/D,IAAK,MAAMZ,KAAKiV,EAAU,CACxB,MAAMc,EAAUd,EAASjV,GACnBF,EAAWiW,EAAQjW,SACrBiW,EAAQC,QACVD,EAAQC,OAAQ,EAChBlW,EAASS,QAAQ,GAAGkO,OAA+B,EAAxBsH,EAAQD,eAEvC,CACF,CACA,OAAA7J,CAAQF,GACN,GAAqB,eAAjBA,EAAMkK,OAAyB,CACjC,MAAMF,EAAUhK,EAAMgK,QAChBjW,EAAWiW,EAAQjW,SACnBoW,EAASH,EAAQG,OACvBlU,KAAK6S,SAAS/T,MAAMkB,KAAMlC,EAAUoW,EACtC,CACAlU,KAAK6S,SAAS5I,QAAQjK,KAAM+J,EAC9B,CACA,OAAA9H,GACEjC,KAAKoJ,MAAQ,KACbpJ,KAAKqC,SAAW,KAChBrC,KAAK6S,SAAW,KAChB,IAAK,MAAM7U,KAAKgC,KAAK4S,eACnB5S,KAAK4S,eAAe5U,GAAGiE,UAEzBjC,KAAK4S,eAAiB,IACxB,GAGFF,EAAatI,UAAY,CACvBC,KAAM,CACJ,KAAcC,WACd,KAAcC,YACd,KAAcC,aAEhBtN,KAAM,SAERwV,EAAaM,mBAAqC/P,OAAOC,OAAO,MAChE,IAAIiR,EAAczB,EAClB,KAAW0B,YAAY,KAAcC,QAASF,EAAYnB,oBAC1D,KAAWnL,IAAIsL,EAAA,G,gEC3Ff,MAAMmB,EAAU,MAAMA,UAAgBC,EAAA,EAIpC,WAAAzU,CAAY0U,GAEVC,MADAD,EAAU,IAAKF,EAAQ/T,kBAAmBiU,IAG1CxU,KAAK0U,SAAU,EAMf1U,KAAK2U,OAASrL,EAAA,EAAMH,QACpBnJ,KAAKqI,UAAYmM,EAAQnM,UACzBrI,KAAK4U,QAAUJ,EAAQI,QACU,kBAAtBJ,EAAQ1T,UACjBd,KAAKc,UAAY0T,EAAQ1T,UAAY,KAAO,MAE5Cd,KAAKc,UAAY0T,EAAQ1T,UAE3Bd,KAAKa,WAAa2T,EAAQ3T,WAC1Bb,KAAK6U,cAAgBL,EAAQK,cAC7B7U,KAAK8U,eAAiBN,EAAQM,eAC9B9U,KAAK+U,YAAY,WAAY,EAAG,EAClC,CAQA,KAAAC,CAAMC,EAAeC,EAAOC,EAAQC,GAClCH,EAAcI,YAAYrV,KAAMkV,EAAOC,EAAQC,EACjD,CAKA,aAAI/M,GACF,OAAOrI,KAAK2U,OAAOtM,SACrB,CAEA,aAAIA,CAAUI,GACZzI,KAAK2U,OAAOtM,UAAYI,CAC1B,CAMA,WAAO6M,CAAKd,GACV,MAAM,IAAEe,EAAG,GAAEC,KAAOC,GAASjB,EAC7B,IAAIkB,EACAC,EAOJ,OANIJ,IACFG,EAAaE,EAAA,EAAWN,KAAKC,IAE3BC,IACFG,EAAYE,EAAA,EAAUP,KAAKE,IAEtB,IAAIlB,EAAQ,CACjBoB,aACAC,eACGF,GAEP,GAMFnB,EAAQ/T,eAAiB,CACvB8H,UAAW,SACXxH,WAAY,EACZ+T,QAAS,EACT9T,UAAW,MACX+T,eAAe,EACfC,gBAAgB,GAElB,IAAIgB,EAASxB,ECxFb,ICAIrT,EAAS,yjFCWb,MAAM8U,UAAmBD,EACvB,WAAAhW,CAAY0U,GACV,MAAM,OAAE1C,KAAW2D,GAASjB,EACtBwB,EAAgB,IAAIC,EAAA,EAAcnE,EAAO9Q,SACzCkV,EAAiB,IAAIC,EAAA,EAAa,CACtCC,cAAe,CAAE3N,MAAO,IAAI7F,EAAA,EAAUyH,KAAM,eAC5CgM,WAAY,CAAE5N,MAAOuN,EAAcM,YAAajM,KAAM,aACtDkM,OAAQ,CAAE9N,MAAO,EAAG4B,KAAM,OAC1BmM,SAAU,CAAE/N,MAAO+L,EAAQiC,QAAU,EAAI,EAAGpM,KAAM,SAiBpDoK,MAAM,IACDgB,EACHC,WAjBiBE,EAAA,EAAWN,KAAK,CACjCnY,OAAQ,CACN8D,OAAM,EACNyV,WAAY,cAEd/Y,SAAU,CACRsD,OAAM,EACNyV,WAAY,kBAWdf,UARgBE,EAAA,EAAUP,KAAK,CAC/BnY,OChCO,m6BDiCPQ,SFjCS,2zBEkCTT,KAAM,gBAMNyZ,UAAW,CACTT,iBACAU,aAAc9E,EAAO9Q,QAAQC,UAGjCjB,KAAK8R,OAASA,EACd9R,KAAK6W,eAAiBb,CACxB,CACA,WAAIS,CAAQhO,GACVzI,KAAK2W,UAAUT,eAAeY,SAASN,SAAW/N,EAAQ,EAAI,CAChE,CACA,WAAIgO,GACF,OAA2D,IAApDzW,KAAK2W,UAAUT,eAAeY,SAASN,QAChD,CACA,KAAAxB,CAAMC,EAAeC,EAAOC,EAAQC,GAClCpV,KAAK6W,eAAe7V,QAAUhB,KAAK8R,OAAO9Q,QAC1CiU,EAAc8B,sBACZ/W,KAAK2W,UAAUT,eAAeY,SAASV,cACvCpW,KAAK8R,QACLkF,QAAQhX,KAAK6W,eAAeI,UAC9BjX,KAAK2W,UAAUC,aAAe5W,KAAK8R,OAAO9Q,QAAQC,OAClDgU,EAAcI,YAAYrV,KAAMkV,EAAOC,EAAQC,EACjD,E,4CElDF,MAAM8B,EAAa,IAAI3G,EAAA,EACvB,MAAM4G,UAAwBC,EAAA,EAC5B,WAAAtX,GACE2U,QACAzU,KAAKqX,QAAU,CAAC,IAAItB,EAAW,CAC7BjE,OAAQ,IAAIwF,EAAA,EAAOnS,EAAA,EAAQoS,OAC3Bd,SAAS,EACT5V,WAAY,UACZC,UAAW,YAEf,CACA,UAAIgR,GACF,OAAO9R,KAAKqX,QAAQ,GAAGvF,MACzB,CACA,UAAIA,CAAOrJ,GACTzI,KAAKqX,QAAQ,GAAGvF,OAASrJ,CAC3B,CACA,WAAIgO,GACF,OAAOzW,KAAKqX,QAAQ,GAAGZ,OACzB,CACA,WAAIA,CAAQhO,GACVzI,KAAKqX,QAAQ,GAAGZ,QAAUhO,CAC5B,EAEF,MAAM+O,EACJ,WAAA1X,CAAYuC,GACVrC,KAAKyX,iBAAmB,GACxBzX,KAAKoD,UAAYf,CACnB,CACA,IAAA3B,CAAKgX,EAAMC,EAAiB9N,GAC1B,MAAMxH,EAAWrC,KAAKoD,UAWtB,GAVAf,EAASyH,YAAYC,MAAMC,MAAMH,GACjCA,EAAehC,IAAI,CACjBiD,aAAc,YACdmJ,OAAQ,gBACRyD,OACAjB,QAASkB,EAAgBC,aAAanB,QACtCoB,WAAW,EACXF,oBAEFD,EAAKjB,QAAUkB,EAAgBC,aAAanB,QACxCiB,EAAKI,oBAAqB,CAC5B,MAAMC,EAAgBL,EAAKA,KAC3BK,EAAcC,gBAAiB,EAC/BD,EAAcE,mBACZpO,EACAxH,EACA,MAEF0V,EAAcC,gBAAiB,CACjC,CACA3V,EAASyH,YAAYC,MAAMC,MAAMH,GACjCA,EAAehC,IAAI,CACjBiD,aAAc,YACdmJ,OAAQ,cACRyD,OACAC,kBACAlB,QAASkB,EAAgBC,aAAanB,QACtCoB,WAAW,GAEf,CACA,GAAA1R,CAAIuR,EAAMQ,EAAkBrO,GACT7J,KAAKoD,UACb0G,YAAYC,MAAMC,MAAMH,GACjCA,EAAehC,IAAI,CACjBiD,aAAc,YACdmJ,OAAQ,aACRyD,OACAjB,QAASyB,EAAiBN,aAAanB,QACvCoB,WAAW,GAEf,CACA,OAAA5N,CAAQY,GACN,MAAMxI,EAAWrC,KAAKoD,UAChB+U,EAAatN,EAAY6M,KAAKI,oBACpC,GAA2B,kBAAvBjN,EAAYoJ,OAA4B,CAC1C,MAAMmE,EAAe,IAAQ9R,IAAI6Q,GAEjC,GADAiB,EAAa3B,QAAU5L,EAAY4L,QAC/B0B,EAAY,CACdtN,EAAY6M,KAAKA,KAAKW,YAAa,EACnC,MAAMtM,GAAS,EAAAuM,EAAA,IAAgBzN,EAAY6M,KAAKA,MAAM,EAAMR,GAC5DrM,EAAY6M,KAAKA,KAAKW,YAAa,EACnCtM,EAAOiE,OACP,MAAMuI,EAAqBlW,EAASoB,aAAaA,aAAatC,aAAaF,OACrEuX,EAAgBtI,EAAA,EAAYI,kBAChCvE,EAAOpL,MACPoL,EAAOnL,OACP2X,EAAmBlX,YACnBkX,EAAmBzX,WAErBuB,EAASoB,aAAa/C,KAAK8X,GAAe,GAC1CnW,EAASgK,eAAe3L,KAAK,CAC3BrC,OAAQ0N,EACRO,WAAY,aAEd,MAAMwF,EAASsG,EAAatG,OAC5BA,EAAO9Q,QAAUwX,EACjB1G,EAAOxE,eAAe1H,GAAKmG,EAAO0M,KAClC3G,EAAOxE,eAAezH,GAAKkG,EAAO2M,KAClC1Y,KAAKyX,iBAAiB/W,KAAK,CACzB0X,eACAT,gBAAiB9M,EAAY8M,gBAC7Ba,iBAEJ,MACEJ,EAAatG,OAASjH,EAAY6M,KAAKA,KACvC1X,KAAKyX,iBAAiB/W,KAAK,CACzB0X,eACAT,gBAAiB9M,EAAY8M,iBAGnC,MAAO,GAA2B,gBAAvB9M,EAAYoJ,OAA0B,CAC/C,MAAM0E,EAAW3Y,KAAKyX,iBAAiBzX,KAAKyX,iBAAiB1T,OAAS,GAClEoU,IACE9V,EAASgI,OAAS,IAAauO,OACjCvW,EAASoB,aAAaF,mBAExBlB,EAASoB,aAAa0C,MACtB9D,EAASgK,eAAelG,OAE1B9D,EAASwW,OAAOnY,KAAK,CACnBoK,aAAc,SACdmJ,OAAQ,aACRrK,UAAW+O,EAAShB,gBACpBS,aAAcO,EAASP,aACvBP,WAAW,GAEf,MAAO,GAA2B,eAAvBhN,EAAYoJ,OAAyB,CAC9C5R,EAASwW,OAAO1S,MAChB,MAAMwS,EAAW3Y,KAAKyX,iBAAiBtR,MACnCgS,GACFjI,EAAA,EAAYC,cAAcwI,EAASH,eAErC,IAAQhN,OAAOmN,EAASP,aAC1B,CACF,CACA,OAAAnW,GACEjC,KAAKoD,UAAY,KACjBpD,KAAKyX,iBAAmB,IAC1B,EAGFD,EAAcpN,UAAY,CACxBC,KAAM,CACJ,KAAcC,WACd,KAAcC,YACd,KAAcC,aAEhBtN,KAAM,aC7JR,MAAM4b,EACJ,WAAAhZ,CAAYuC,GACVrC,KAAK+Y,YAAc,GACnB/Y,KAAKgZ,iBAAmB,EACxBhZ,KAAKiZ,cAAgB,EACrBjZ,KAAKoD,UAAYf,CACnB,CACA,UAAA6O,GACElR,KAAK+Y,YAAY,GAAK,GACtB/Y,KAAKgZ,iBAAmB,EACxBhZ,KAAKiZ,cAAgB,EACvB,CACA,IAAAvY,CAAKgX,EAAMwB,EAAYrP,GACJ7J,KAAKoD,UACb0G,YAAYC,MAAMC,MAAMH,GACjC,MAAMsP,EAAanZ,KAAK+Y,YACxBI,EAAWnZ,KAAKgZ,kBAAoBG,EAAWnZ,KAAKgZ,iBAAmB,GAAKtB,EAAKA,KACjF,MAAM0B,EAAepZ,KAAK+Y,YAAY/Y,KAAKgZ,kBACvCI,IAAiBpZ,KAAKiZ,gBACxBjZ,KAAKiZ,cAAgBG,EACrBvP,EAAehC,IAAI,CACjBiD,aAAc,YACdqG,UAAWiI,EACXvB,WAAW,KAGf7X,KAAKgZ,kBACP,CACA,GAAA7S,CAAIkT,EAAOH,EAAYrP,GACJ7J,KAAKoD,UACb0G,YAAYC,MAAMC,MAAMH,GACjC,MAAMsP,EAAanZ,KAAK+Y,YACxB/Y,KAAKgZ,mBACL,MAAMI,EAAeD,EAAWnZ,KAAKgZ,iBAAmB,GACpDI,IAAiBpZ,KAAKiZ,gBACxBjZ,KAAKiZ,cAAgBG,EACrBvP,EAAehC,IAAI,CACjBiD,aAAc,YACdqG,UAAWiI,EACXvB,WAAW,IAGjB,CACA,OAAA5N,CAAQY,GACW7K,KAAKoD,UACb+N,UAAUmI,QAAQzO,EAAYsG,UACzC,CACA,OAAAlP,GACEjC,KAAK+Y,YAAc,IACrB,EAGFD,EAAc1O,UAAY,CACxBC,KAAM,CACJ,KAAcC,WACd,KAAcC,YACd,KAAcC,aAEhBtN,KAAM,a,wBCxDR,MAAMqc,EACJ,WAAAzZ,CAAYuC,GAEVrC,KAAKwZ,eAAiB,CAAC,EACvBxZ,KAAKyZ,UAA4B,IAAIC,QACrC1Z,KAAKoD,UAAYf,CACnB,CACA,IAAA3B,CAAKgX,EAAMwB,EAAYrP,GACrB,IAAI8P,EACJ,MAAMC,EAASlC,EACTrV,EAAWrC,KAAKoD,UACtBf,EAASyH,YAAYC,MAAMC,MAAMH,GACjCxH,EAASyH,YAAYzB,UAAUwR,aAAaD,EAAOlC,KAAM,OAAQ7N,GACjEA,EAAehC,IAAI,CACjBiD,aAAc,cACdmJ,OAAQ,gBACRyD,OACAjB,QAASyC,EAAWtB,aAAanB,QACjCoB,WAAW,IAEb,MAAME,EAAgB6B,EAAOlC,KAC7BK,EAAcC,gBAAiB,EAC1BhY,KAAKyZ,UAAUK,IAAIF,IACtB5Z,KAAKyZ,UAAUjS,IAAIoS,EAAQ,CACzBG,kBAAmB,EACnBC,mBAAoB,IAGxB,MAAMrB,EAAW3Y,KAAKyZ,UAAUnT,IAAIsT,GACpCjB,EAASoB,kBAAoBlQ,EAAee,gBAC5CmN,EAAcE,mBACZpO,EACAxH,EACA,MAEF0V,EAAcC,gBAAiB,EAC/B3V,EAASyH,YAAYC,MAAMC,MAAMH,GACjCA,EAAehC,IAAI,CACjBiD,aAAc,cACdmJ,OAAQ,cACRyD,OACAjB,QAASyC,EAAWtB,aAAanB,QACjCoB,WAAW,IAEb,MAAMmC,EAAqBnQ,EAAee,gBAAkB+N,EAASoB,kBAAoB,EACzFpB,EAASqB,mBAAqBA,EAC9B,MAAMC,EAAkB5X,EAASoB,aAAaA,aAAa7E,KAC1D+a,EAAK3Z,KAAKwZ,gBAAgBS,KAAqBN,EAAGM,GAAmB,EACxE,CACA,GAAA9T,CAAIuR,EAAMwB,EAAYrP,GACpB,MAAM+P,EAASlC,EACTrV,EAAWrC,KAAKoD,UACtBf,EAASyH,YAAYC,MAAMC,MAAMH,GACjCxH,EAASyH,YAAYzB,UAAUwR,aAAaD,EAAOlC,KAAM,OAAQ7N,GACjEA,EAAehC,IAAI,CACjBiD,aAAc,cACdmJ,OAAQ,eACRwC,QAASyC,EAAWtB,aAAanB,QACjCoB,WAAW,IAEb,MAAMc,EAAW3Y,KAAKyZ,UAAUnT,IAAIoR,GACpC,IAAK,IAAI1Z,EAAI,EAAGA,EAAI2a,EAASqB,mBAAoBhc,IAC/C6L,EAAec,aAAad,EAAee,mBAAqBf,EAAec,aAAagO,EAASoB,qBAEvGlQ,EAAehC,IAAI,CACjBiD,aAAc,cACdmJ,OAAQ,aACR4D,WAAW,GAEf,CACA,OAAA5N,CAAQY,GACN,IAAI8O,EACJ,MAAMtX,EAAWrC,KAAKoD,UAChB6W,EAAkB5X,EAASoB,aAAaA,aAAa7E,IAC3D,IAAIsb,GAAkBP,EAAK3Z,KAAKwZ,gBAAgBS,KAAqBN,EAAGM,GAAmB,GAChE,kBAAvBpP,EAAYoJ,QACd5R,EAASoB,aAAasD,qBACtB1E,EAAS7B,QAAQ2Z,eAAe,IAAc9a,mBAAoB6a,GAClEA,IACA7X,EAAS8O,UAAUmI,QAAQ,IACK,gBAAvBzO,EAAYoJ,QACjBpJ,EAAY4L,QACdpU,EAAS7B,QAAQ2Z,eAAe,IAAcva,oBAAqBsa,GAEnE7X,EAAS7B,QAAQ2Z,eAAe,IAAcxa,YAAaua,GAE7D7X,EAAS8O,UAAUmI,QAAQ,KACK,iBAAvBzO,EAAYoJ,QACrB5R,EAAS8O,UAAUmI,QAAQ,GACJ,IAAnBY,EACF7X,EAAS7B,QAAQ2Z,eAAe,IAAcza,sBAAuBwa,IAErE7X,EAASoB,aAAaG,MAAM,KAAM,IAAMwW,SACxC/X,EAAS7B,QAAQ2Z,eAAe,IAAcjb,SAAUgb,IAE1DA,KACgC,eAAvBrP,EAAYoJ,SACjBpJ,EAAY4L,QACdpU,EAAS7B,QAAQ2Z,eAAe,IAAcva,oBAAqBsa,GAEnE7X,EAAS7B,QAAQ2Z,eAAe,IAAcxa,YAAaua,GAE7D7X,EAAS8O,UAAUmI,QAAQ,KAE7BtZ,KAAKwZ,eAAeS,GAAmBC,CACzC,CACA,OAAAjY,GACEjC,KAAKoD,UAAY,KACjBpD,KAAKwZ,eAAiB,KACtBxZ,KAAKyZ,UAAY,IACnB,EAEFF,EAAgBnP,UAAY,CAC1BC,KAAM,CACJ,KAAcC,WACd,KAAcC,YACd,KAAcC,aAEhBtN,KAAM,e,cCvHR,MAAMmd,EAAoB,MAAMA,EAC9B,WAAAva,GACEE,KAAKsa,mBAAoB,EACzBta,KAAKua,iBAAmB,IAAIC,EAAA,EAAM,GAClCxa,KAAKya,MAAQza,KAAKua,iBAClBva,KAAK0a,MAAQ,CACf,CAKA,IAAA5H,CAAK0B,GACHA,EAAU,IAAK6F,EAAkB9Z,kBAAmBiU,GACpDxU,KAAKsa,kBAAoB9F,EAAQ8F,kBACjCta,KAAKya,MAAQjG,EAAQmG,YAAcnG,EAAQoG,iBAAmB5a,KAAKua,iBACnEva,KAAK0a,MAAQlG,EAAQqG,gBACrB7a,KAAKua,iBAAiBO,SAAStG,EAAQqG,gBACzC,CAEA,SAAIJ,GACF,OAAOza,KAAKua,gBACd,CACA,SAAIE,CAAMhS,GACRzI,KAAKua,iBAAiBQ,SAAStS,EACjC,CAEA,SAAIiS,GACF,OAAO1a,KAAKua,iBAAiBG,KAC/B,CACA,SAAIA,CAAMjS,GACRzI,KAAKua,iBAAiBO,SAASrS,EACjC,CAEA,aAAIuS,GACF,OAAOhb,KAAKua,iBAAiBU,SAC/B,CAMA,OAAAhZ,GACA,GAGFoY,EAAkBjQ,UAAY,CAC5BC,KAAM,CACJ,KAAcmH,YACd,KAAcC,aACd,KAAcC,cAEhBxU,KAAM,aACNge,SAAU,GAGZb,EAAkB9Z,eAAiB,CAKjCsa,gBAAiB,EAKjBD,gBAAiB,EAKjBN,mBAAmB,GAErB,IAAIa,EAAmBd,E,aCvEvB,MAAMe,GAAqB,CAAC,EAC5B,KAAWC,OAAO,KAAcC,WAAY7S,IAC1C,IAAKA,EAAMvL,KACT,MAAM,IAAIqe,MAAM,iDAElBH,GAAmB3S,EAAMvL,MAAQuL,EAAM+S,GAAG,IACxC/S,WACK2S,GAAmB3S,EAAMvL,KAAK,IAEvC,MAAMue,GACJ,WAAA3b,CAAYuC,GACVrC,KAAK0b,aAAc,EACnB1b,KAAK2b,YAA8B1Y,OAAOC,OAAO,MACjDlD,KAAKoD,UAAYf,EACjBrC,KAAKoD,UAAUwY,QAAQlX,UAAUmD,IAAI7H,KACvC,CACA,SAAA0E,GACE1E,KAAK6b,iBAAmB,SACxB7b,KAAK0b,aAAc,CACrB,CAOA,YAAA7B,CAAalO,EAAYtD,EAAWwB,GAC9B7J,KAAK6b,mBAAqBxT,GAK9BrI,KAAK6b,iBAAmBxT,EACpBrI,KAAK0b,aACP1b,KAAK8b,sBAAsBjS,GAE7B7J,KAAK0b,cAAgBN,GAAmB/S,GACpCrI,KAAK0b,cACP1b,KAAK+b,wBAAwBlS,GAC7B7J,KAAKgc,gBAAgBtb,KAAKiL,KAXtB3L,KAAK0b,aACP1b,KAAKgc,gBAAgBtb,KAAKiL,EAYhC,CACA,uBAAAoQ,CAAwBlS,GACtB7J,KAAKoD,UAAU0G,YAAYC,MAAMC,MAAMH,GACvC,MAAMxB,EAAYrI,KAAK6b,iBACvB,IAAKT,GAAmB/S,GAEtB,YADA,EAAA4T,EAAA,GAAK,gCAAgC5T,sEAGvC,IAAI+P,EAAepY,KAAK2b,YAAYtT,GAC/B+P,IACHA,EAAepY,KAAK2b,YAAYtT,GAAa,IAAI+O,EAAA,EACjDgB,EAAaf,QAAU,CAAC,IAAI+D,GAAmB/S,KAEjD,MAAMwC,EAAc,CAClBC,aAAc,SACdmJ,OAAQ,aACRiI,YAAa,GACb9D,eACAP,WAAW,GAEb7X,KAAKgc,gBAAkBnR,EAAYqR,YACnCrS,EAAehC,IAAIgD,EACrB,CACA,qBAAAiR,CAAsBjS,GACpB7J,KAAKgc,gBAAkB,KACvBhc,KAAKoD,UAAU0G,YAAYC,MAAMC,MAAMH,GACvCA,EAAehC,IAAI,CACjBiD,aAAc,SACdmJ,OAAQ,YACR4D,WAAW,GAEf,CAMA,UAAA3G,GACElR,KAAK0b,aAAc,CACrB,CAQA,QAAAnK,CAAS1H,GACH7J,KAAK0b,aACP1b,KAAK8b,sBAAsBjS,EAE/B,CAKA,OAAA5H,GACEjC,KAAKoD,UAAY,KACjBpD,KAAKgc,gBAAkB,KACvB,IAAK,MAAMhe,KAAKgC,KAAK2b,YACnB3b,KAAK2b,YAAY3d,GAAGiE,UAEtBjC,KAAK2b,YAAc,IACrB,EAGFF,GAAcrR,UAAY,CACxBC,KAAM,CACJ,KAAcC,WACd,KAAcC,YACd,KAAcC,aAEhBtN,KAAM,aCjHR,MAAMif,GAAa,CACjBC,IAAK,YACLC,IAAK,aACLC,KAAM,cAEFC,GAAiB,MAAMA,EAE3B,WAAAzc,CAAYuC,GACVrC,KAAKoD,UAAYf,CACnB,CACA,iBAAAma,CAAkBhI,EAASiI,EAAW,CAAC,GACrC,OAAIjI,aAAmBxH,EAAA,IAAawH,aAAmBrP,EAAA,EAC9C,CACLxB,OAAQ6Q,KACLiI,GAGA,IACFA,KACAjI,EAEP,CAMA,WAAMkI,CAAMlI,GACV,MAAMkI,EAAQ,IAAIC,MAElB,OADAD,EAAME,UAAY5c,KAAK6c,OAAOrI,GACvBkI,CACT,CAMA,YAAMG,CAAOrI,GACXA,EAAUxU,KAAKwc,kBACbhI,EACA+H,EAAeO,qBAEjB,MAAM,OAAE1e,EAAM,QAAE2e,GAAYvI,EACtBwI,EAAShd,KAAKgd,OAAOxI,GAC3B,QAAsB,IAAlBwI,EAAOC,OACT,OAAO,IAAIC,SAAQ,CAACC,EAASC,KAC3BJ,EAAOC,QAAQI,IACb,IAAKA,EAEH,YADAD,EAAO,IAAI7B,MAAM,2BAGnB,MAAM+B,EAAS,IAAIC,WACnBD,EAAOE,OAAS,IAAML,EAAQG,EAAOG,QACrCH,EAAOI,QAAUN,EACjBE,EAAOK,cAAcN,EAAK,GACzBlB,GAAW/d,GAAS2e,EAAQ,IAGnC,QAAyB,IAArBC,EAAOY,UACT,OAAOZ,EAAOY,UAAUzB,GAAW/d,GAAS2e,GAE9C,QAA6B,IAAzBC,EAAOa,cAA0B,CACnC,MAAMR,QAAaL,EAAOa,cAAc,CAAExT,KAAM8R,GAAW/d,GAAS2e,YACpE,OAAO,IAAIG,SAAQ,CAACC,EAASC,KAC3B,MAAME,EAAS,IAAIC,WACnBD,EAAOE,OAAS,IAAML,EAAQG,EAAOG,QACrCH,EAAOI,QAAUN,EACjBE,EAAOK,cAAcN,EAAK,GAE9B,CACA,MAAM,IAAI9B,MAAM,0GAClB,CAMA,MAAAyB,CAAOxI,GAEL,MAAM7Q,GADN6Q,EAAUxU,KAAKwc,kBAAkBhI,IACV7Q,OACjBtB,EAAWrC,KAAKoD,UACtB,GAAIO,aAAkBwB,EAAA,EACpB,OAAO9C,EAASrB,QAAQ8c,eAAena,GAEzC,MAAM3C,EAAUqB,EAAS0b,iBAAiBC,gBAAgBxJ,GACpDwI,EAAS3a,EAASrB,QAAQ8c,eAAe9c,GAE/C,OADAA,EAAQiB,SAAQ,GACT+a,CACT,CAOA,MAAAiB,CAAOzJ,GAEL,MAAM7Q,GADN6Q,EAAUxU,KAAKwc,kBAAkBhI,IACV7Q,OACjBtB,EAAWrC,KAAKoD,UAChBpC,EAAU2C,aAAkBwB,EAAA,EAAUxB,EAAStB,EAAS0b,iBAAiBC,gBAAgBxJ,GACzF0J,EAAY7b,EAASrB,QAAQmd,UAAUnd,GAI7C,OAHI2C,aAAkBqJ,EAAA,IACpBhM,EAAQiB,SAAQ,GAEXic,CACT,CAMA,OAAAld,CAAQwT,GAEN,OADAA,EAAUxU,KAAKwc,kBAAkBhI,IACrB7Q,kBAAkBwB,EAAA,EACrBqP,EAAQ7Q,OACV3D,KAAKoD,UAAU2a,iBAAiBC,gBAAgBxJ,EACzD,CAKA,QAAA4J,CAAS5J,GACPA,EAAUxU,KAAKwc,kBAAkBhI,GACjC,MAAMwI,EAAShd,KAAKgd,OAAOxI,GACrB6J,EAAO/Z,SAASga,cAAc,KACpCD,EAAKD,SAAW5J,EAAQ+J,UAAY,YACpCF,EAAKG,KAAOxB,EAAOY,UAAU,aAC7BtZ,SAASC,KAAKka,YAAYJ,GAC1BA,EAAKK,QACLpa,SAASC,KAAKoa,YAAYN,EAC5B,CAKA,GAAAO,CAAIpK,GACF,MAAM7T,EAAQ6T,EAAQ7T,OAAS,IAC/B6T,EAAUxU,KAAKwc,kBAAkBhI,GACjC,MAAMwI,EAAShd,KAAKgd,OAAOxI,GACrBqI,EAASG,EAAOY,YACtBiB,QAAQD,IAAI,kBAAkB5B,EAAOrc,WAAWqc,EAAOpc,YACvD,MAAMke,EAAQ,CACZ,kBACA,YAAYne,aACZ,mBAAmBkc,gBACnB,6BACAkC,KAAK,KACPF,QAAQD,IAAI,MAAOE,EACrB,CACA,OAAA7c,GACEjC,KAAKoD,UAAY,IACnB,GAGFmZ,GAAenS,UAAY,CACzBC,KAAM,CACJ,KAAcmH,YACd,KAAcC,cAEhBvU,KAAM,WAGRqf,GAAeO,oBAAsB,CAEnC1e,OAAQ,MAER2e,QAAS,GAEX,IAAIiC,GAAgBzC,G,oCCzKpB,MAAM0C,WAAsB9Z,EAAA,EAC1B,aAAOjC,CAAOsR,GACZ,OAAO,IAAIyK,GAAc,CACvBhe,OAAQ,IAAImG,GAAA,EAAcoN,IAE9B,CAQA,MAAApT,CAAOT,EAAOC,EAAQC,GAEpB,OADAb,KAAKiB,OAAOG,OAAOT,EAAOC,EAAQC,GAC3Bb,IACT,ECVF,MAAMkf,GAAW,IAAI3c,GAAA,EACf,GAAa,IAAIgO,EAAA,EACjB4O,GAAU,CAAC,EAAG,EAAG,EAAG,GAC1B,MAAMC,GACJ,WAAAtf,CAAYuC,GACVrC,KAAKoD,UAAYf,CACnB,CAYA,eAAA2b,CAAgBxJ,GACVA,aAAmBxH,EAAA,KACrBwH,EAAU,CACR7Q,OAAQ6Q,EACR1Q,WAAO,EACPub,qBAAsB,CAAC,EACvBxe,gBAAY,IAGhB,MAAMA,EAAa2T,EAAQ3T,YAAcb,KAAKoD,UAAUvC,WAClDC,EAAY0T,EAAQ1T,WAAad,KAAKoD,UAAUiN,KAAKvP,UACrD8I,EAAY4K,EAAQ7Q,OAC1B,IAAIE,EAAa2Q,EAAQ3Q,WAGvBA,EAFEA,EACkByb,MAAMC,QAAQ1b,IAAqC,IAAtBA,EAAWE,OACjCF,EAAa2W,EAAA,EAAMgF,OAAOzE,SAASlX,GAAYoX,UAE7DkE,GAEf,MAAMM,EAASjL,EAAQ1Q,OAAO4b,OAAOR,MAAa,EAAAnP,GAAA,GAAenG,EAAW,IAAY+V,UACxFF,EAAO9e,MAAiD,EAAzCkG,KAAKqB,IAAIuX,EAAO9e,MAAO,EAAIE,GAC1C4e,EAAO7e,OAAmD,EAA1CiG,KAAKqB,IAAIuX,EAAO7e,OAAQ,EAAIC,GAC5C,MAAM8C,EAASsb,GAAc/b,OAAO,IAC/BsR,EAAQ6K,qBACX1e,MAAO8e,EAAO9e,MACdC,OAAQ6e,EAAO7e,OACfC,aACAC,cAEI+K,EAAYjJ,EAAA,EAAO4c,OAAOpT,WAAWqT,EAAOra,GAAIqa,EAAOpa,GAQ7D,OAPArF,KAAKoD,UAAU+G,OAAO,CACpBP,YACAiC,YACAlI,SACAE,eAEFF,EAAO1C,OAAO2e,gBACPjc,CACT,CACA,OAAA1B,GACEjC,KAAKoD,UAAY,IACnB,EAGFgc,GAAsBhV,UAAY,CAChCC,KAAM,CACJ,KAAcmH,YACd,KAAcC,cAEhBvU,KAAM,oB,qCCpER,MAAM2iB,GACJ,WAAA/f,CAAYuC,GACVrC,KAAK8f,YAAc,EACnB9f,KAAK+f,wBAA0B,GAC/B/f,KAAKggB,cAAgB,GACrBhgB,KAAKigB,gBAAkB,GACvBjgB,KAAKkgB,eAAiB,GACtBlgB,KAAKmgB,kBAAoB,GACzBngB,KAAKoD,UAAYf,CACnB,CACA,KAAA4O,GACEjR,KAAK8f,YAAc,EACnB,IAAK,IAAI9hB,EAAI,EAAGA,EAAIgC,KAAKigB,gBAAgBlc,OAAQ/F,IAC/CgC,KAAKggB,cAActf,KAAKV,KAAKigB,gBAAgBjiB,IAE/C,IAAK,IAAIA,EAAI,EAAGA,EAAIgC,KAAKmgB,kBAAkBpc,OAAQ/F,IACjDgC,KAAKkgB,eAAexf,KAAKV,KAAKmgB,kBAAkBniB,IAElDgC,KAAKigB,gBAAgBlc,OAAS,EAC9B/D,KAAKmgB,kBAAkBpc,OAAS,CAClC,CACA,KAAAjF,CAAM0V,GACJxU,KAAKiR,QACLjR,KAAKU,KAAK8T,EACZ,CACA,IAAA5P,EAAK,KACHlD,EAAI,iBACJiB,EAAgB,qBAChBwJ,EAAoB,WACpBG,EAAU,OACVjO,IAEA,MAAMoF,EAAezD,KAAKoD,UAAUK,aAAaA,aAC3C2c,EAA2BpgB,KAAK8f,YAAc9f,KAAK+f,wBAAwB/f,KAAK8f,YAAc,GAAK,CACvGO,eAAgB5c,EAChB0I,qBAAsB,IAAIvJ,EAAA,EAC1B0J,WAAY,WACZjO,OAAQ,IAAIiiB,GAAA,GAERC,EAAoB,CACxB5d,iBAAkBA,GAAoB3C,KAAKoD,UAAUK,aAAad,iBAClE9B,WAAYa,GAAQ+B,EAAa/B,KACjCyK,qBAAsBA,GAAwBiU,EAAyBjU,qBACvEG,WAAYA,GAAc8T,EAAyB9T,WACnDjO,OAAQA,GAAU+hB,EAAyB/hB,OAC3CmiB,UAAW,MAEPC,EAAezgB,KAAKggB,cAAc7Z,OAASnG,KAAK0gB,kBACtD1gB,KAAKigB,gBAAgBvf,KAAK+f,GAC1B,MAAM3J,EAAW2J,EAAa3J,SAY9B,IAAI0J,EAXJ1J,EAAS6J,kBAAoBJ,EAAkB5d,iBAC/CmU,EAAS8J,YAAcL,EAAkB1f,WACzCiW,EAAS+J,sBAAsB7c,SAASuc,EAAkBpU,sBAC1D2K,EAAS+J,sBAAsBjb,IAAM2a,EAAkBliB,OAAO+G,EAC9D0R,EAAS+J,sBAAsBhb,IAAM0a,EAAkBliB,OAAOgH,GAC9D,QACEkb,EAAkBjU,WAClBwK,EAASgK,iBACT,GAEFL,EAAahU,SAETzM,KAAKoD,UAAU0G,YAAY2F,aAC7B+Q,EAAYxgB,KAAKoD,UAAU0G,YAAY2F,aAAasR,oBAAoBN,GAAc,IAEtFD,EAAYxgB,KAAKkgB,eAAe/Z,OAAS,IAAI6a,GAAA,EAC7ChhB,KAAKmgB,kBAAkBzf,KAAK8f,GAC5BA,EAAUS,YAAYR,EAAc,IAEtCF,EAAkBC,UAAYA,EAC9BxgB,KAAKkhB,0BAA4BX,CACnC,CACA,IAAA7f,CAAK8T,GACHxU,KAAK4E,KAAK4P,GACVxU,KAAK+f,wBAAwB/f,KAAK8f,eAAiB9f,KAAKkhB,yBAC1D,CACA,GAAA/a,GACEnG,KAAKkhB,0BAA4BlhB,KAAK+f,0BAA0B/f,KAAK8f,YAAc,GAC/E9f,KAAKoD,UAAUiH,OAAS,IAAauO,OACvC5Y,KAAKkhB,0BAA0BV,UAAU7J,UAAU,GAAGlK,QAE1D,CACA,aAAI+T,GACF,OAAOxgB,KAAKkhB,0BAA0BV,SACxC,CACA,qBAAID,GACF,OAAOvgB,KAAKkhB,yBACd,CACA,gBAAIT,GACF,OAAOzgB,KAAKkhB,0BAA0BV,UAAU7J,UAAU,EAC5D,CACA,eAAA+J,GAUE,OATuB,IAAIvK,EAAA,EAAa,CACtCwK,kBAAmB,CAAElY,MAAO,IAAI7F,EAAA,EAAUyH,KAAM,eAChDwW,sBAAuB,CAAEpY,MAAO,IAAI7F,EAAA,EAAUyH,KAAM,eAEpDyW,iBAAkB,CAAErY,MAAO,IAAIpI,aAAa,GAAIgK,KAAM,aACtDuW,YAAa,CAAEnY,MAAO,CAAC,EAAG,GAAI4B,KAAM,cACnC,CACD8W,UAAU,GAGd,CACA,OAAAlf,GACEjC,KAAKoD,UAAY,IACnB,EAGFyc,GAAoBzV,UAAY,CAC9BC,KAAM,CACJ,KAAcmH,YACd,KAAcC,aACd,KAAcC,cAEhBxU,KAAM,kB,eCvHR,IAAI0B,GAAM,EACV,MAAMwiB,GACJ,WAAAthB,GACEE,KAAKqhB,OAAS,GAEdrhB,KAAKshB,QAAU,CACjB,CAEA,IAAAxO,GACEyO,GAAA,EAAOC,OAAO3Z,IAAI7H,KAAKyhB,QAASzhB,KAClC,CAQA,MAAA0hB,CAAOC,EAAMC,EAAUC,GAAY,GACjC,MAAMC,EAAKljB,KACX,IAAIP,EAAS,EAcb,OAbIwjB,IACF7hB,KAAKshB,SAAW,IAChBjjB,EAAS2B,KAAKshB,SAEhBthB,KAAKqhB,OAAO3gB,KAAK,CACfihB,OACAC,WACA9iB,MAAOijB,YAAYC,MACnB3jB,SACA4jB,KAAMF,YAAYC,MAClBN,QAAQ,EACRI,OAEKA,CACT,CAKA,MAAAI,CAAOJ,GACL,IAAK,IAAI9jB,EAAI,EAAGA,EAAIgC,KAAKqhB,OAAOtd,OAAQ/F,IACtC,GAAIgC,KAAKqhB,OAAOrjB,GAAG8jB,KAAOA,EAExB,YADA9hB,KAAKqhB,OAAOc,OAAOnkB,EAAG,EAI5B,CAKA,OAAAyjB,GACE,MAAMO,EAAMD,YAAYC,MACxB,IAAK,IAAIhkB,EAAI,EAAGA,EAAIgC,KAAKqhB,OAAOtd,OAAQ/F,IAAK,CAC3C,MAAMokB,EAAOpiB,KAAKqhB,OAAOrjB,GACzB,GAAIgkB,EAAMI,EAAK/jB,OAAS+jB,EAAKH,MAAQG,EAAKR,SAAU,CAClD,MAAMS,EAAUL,EAAMI,EAAKtjB,MAC3BsjB,EAAKT,KAAKU,GACVD,EAAKH,KAAOD,CACd,CACF,CACF,CAMA,OAAA/f,GACEsf,GAAA,EAAOC,OAAOc,OAAOtiB,KAAKyhB,QAASzhB,MACnCA,KAAKqhB,OAAOtd,OAAS,CACvB,EAGFqd,GAAgBhX,UAAY,CAC1BC,KAAM,CACJ,KAAcmH,YACd,KAAcC,aACd,KAAcC,cAEhBxU,KAAM,YACNge,SAAU,G,0BCjFZ,IAAIqH,IAAY,ECChB,MAAMC,GACJ,WAAA1iB,CAAYuC,GACVrC,KAAKoD,UAAYf,CACnB,CAKA,IAAAyQ,CAAK0B,GACH,GAAIA,EAAQiO,MAAO,CACjB,IAAIvlB,EAAO8C,KAAKoD,UAAUlG,KACtB8C,KAAKoD,UAAUiH,OAAS,IAAauO,QACvC1b,GAAQ,IAAI8C,KAAKoD,UAAUsf,QAAQC,gBDZ3C,SAAkBtY,GAChB,IAAIkY,GAAJ,CAGA,GAAI,KAAWjc,MAAMsc,eAAeC,UAAUC,cAAcC,QAAQ,WAAa,EAAG,CAClF,MAAMC,EAAO,CACX,iCAAiC,UAAY3Y,gCAG7C,sCACA,sCACA,sCACA,sCACA,sDACA,uDAEFjG,WAAWya,QAAQD,OAAOoE,EAC5B,MAAW5e,WAAWya,SACpBza,WAAWya,QAAQD,IAAI,UAAU,WAAavU,8BAEhDkY,IAAY,CAjBZ,CAkBF,CCPMU,CAAS/lB,EACX,CACF,ECpBF,SAASgmB,GAAUC,GACjB,IAAIC,GAAQ,EACZ,IAAK,MAAMplB,KAAKmlB,EACd,GAAe,MAAXA,EAAKnlB,GAAc,CACrBolB,GAAQ,EACR,KACF,CAEF,IAAKA,EACH,OAAOD,EACT,MAAME,EAA6BpgB,OAAOC,OAAO,MACjD,IAAK,MAAMlF,KAAKmlB,EAAM,CACpB,MAAM1a,EAAQ0a,EAAKnlB,GACfyK,IACF4a,EAAWrlB,GAAKyK,EAEpB,CACA,OAAO4a,CACT,CACA,SAASC,GAAWC,GAClB,IAAIllB,EAAS,EACb,IAAK,IAAIL,EAAI,EAAGA,EAAIulB,EAAIxf,OAAQ/F,IAChB,MAAVulB,EAAIvlB,GACNK,IAEAklB,EAAIvlB,EAAIK,GAAUklB,EAAIvlB,GAI1B,OADAulB,EAAIxf,QAAU1F,EACPklB,CACT,CDPAf,GAAYpY,UAAY,CACtBC,KAAM,CACJ,KAAcmH,YACd,KAAcC,aACd,KAAcC,cAEhBxU,KAAM,QACNge,UAAW,GAGbsH,GAAYjiB,eAAiB,CAE3BkiB,OAAO,GEhCT,IAAIe,GAAmB,EACvB,MAAMC,GAAsB,MAAMA,EAKhC,WAAA3jB,CAAYuC,GAEVrC,KAAK0jB,oBAAsB,GAE3B1jB,KAAK2jB,eAAiB,GAEtB3jB,KAAK4jB,eAAiB,GACtB5jB,KAAKoD,UAAYf,CACnB,CAKA,IAAAyQ,CAAK0B,GACHA,EAAU,IAAKiP,EAAoBljB,kBAAmBiU,GACtDxU,KAAK6jB,cAAgBrP,EAAQsP,0BAC7B9jB,KAAK+jB,WAAavP,EAAQwP,sBAC1BhkB,KAAK0U,QAAUF,EAAQyP,kBACzB,CAKA,WAAIvP,GACF,QAAS1U,KAAKkkB,QAChB,CAMA,WAAIxP,CAAQjM,GACNzI,KAAK0U,UAAYjM,IAEjBA,GACFzI,KAAKkkB,SAAWlkB,KAAKoD,UAAU+gB,UAAUzC,QACvC,IAAM1hB,KAAKokB,OACXpkB,KAAK+jB,YACL,GAEF/jB,KAAKqkB,aAAerkB,KAAKoD,UAAU+gB,UAAUzC,QAC3C,KACE,IAAK,MAAMyB,KAAQnjB,KAAK2jB,eACtBR,EAAKT,QAAQS,EAAKA,MAAQD,GAAUC,EAAKT,QAAQS,EAAKA,MACxD,GAEFnjB,KAAK+jB,YAEP/jB,KAAKskB,cAAgBtkB,KAAKoD,UAAU+gB,UAAUzC,QAC5C,KACE,IAAK,MAAM6C,KAASvkB,KAAK4jB,eACvBN,GAAWiB,EAAM7B,QAAQ6B,EAAMpB,MACjC,GAEFnjB,KAAK+jB,cAGP/jB,KAAKoD,UAAU+gB,UAAUjC,OAAOliB,KAAKkkB,UACrClkB,KAAKoD,UAAU+gB,UAAUjC,OAAOliB,KAAKqkB,cACrCrkB,KAAKoD,UAAU+gB,UAAUjC,OAAOliB,KAAKskB,gBAEzC,CAMA,cAAAhhB,CAAeof,EAASS,GACtBnjB,KAAK2jB,eAAejjB,KAAK,CAAEgiB,UAASS,QACtC,CAMA,eAAAqB,CAAgB9B,EAASS,GACvBnjB,KAAK4jB,eAAeljB,KAAK,CAAEgiB,UAASS,QACtC,CAMA,SAAAze,EAAU,UACRkF,IAEA5J,KAAKykB,KAAO1C,YAAYC,MACxBpY,EAAUc,YAAYga,OAASlB,KAC/BxjB,KAAK2kB,yBAAyB/a,EAAUc,YAAad,EAAUc,YAAYga,OAC7E,CAKA,aAAA/a,CAAcgC,GACP3L,KAAK0U,WAEoB,IAA1B/I,EAAWiZ,YACb5kB,KAAK0jB,oBAAoBhjB,KAAKiL,GAC9BA,EAAWtE,KAAK,YAAarH,KAAK6kB,kBAAmB7kB,OAEvD2L,EAAWiZ,UAAY5kB,KAAKykB,KAC9B,CAKA,GAAAL,GACE,MAAMpC,EAAMhiB,KAAKykB,KACXK,EAAqB9kB,KAAK0jB,oBAC1B5Z,EAAc9J,KAAKoD,UAAU0G,YACnC,IAAIzL,EAAS,EACb,IAAK,IAAIL,EAAI,EAAGA,EAAI8mB,EAAmB/gB,OAAQ/F,IAAK,CAClD,MAAM2N,EAAamZ,EAAmB9mB,GACtC,GAAmB,OAAf2N,EAAqB,CACvBtN,IACA,QACF,CACA,MAAMqM,EAAciB,EAAWjB,aAAeiB,EAAW0C,kBACnD0W,EAAcra,GAAab,gBAAgB6a,SAAW,EAI5D,IAHKha,GAAaga,QAAU,KAAOK,IACjCpZ,EAAWiZ,UAAY5C,GAErBA,EAAMrW,EAAWiZ,UAAY5kB,KAAK6jB,cAAe,CACnD,IAAKlY,EAAWqZ,UAAW,CACzB,MAAMC,EAAKnb,EACPY,IACFA,EAAYqE,oBAAqB,GACnCkW,EAAGtZ,EAAWb,cAAcrB,kBAAkBkC,EAChD,CACAA,EAAWiZ,WAAa,EACxBvmB,IACAsN,EAAWzJ,IAAI,YAAalC,KAAK6kB,kBAAmB7kB,KACtD,MACE8kB,EAAmB9mB,EAAIK,GAAUsN,CAErC,CACAmZ,EAAmB/gB,QAAU1F,CAC/B,CAEA,OAAA4D,GACEjC,KAAK0U,SAAU,EACf1U,KAAKoD,UAAY,KACjBpD,KAAK0jB,oBAAoB3f,OAAS,EAClC/D,KAAK2jB,eAAe5f,OAAS,EAC7B/D,KAAK4jB,eAAe7f,OAAS,CAC/B,CAKA,iBAAA8gB,CAAkBlZ,GAChB,MAAMmB,EAAQ9M,KAAK0jB,oBAAoBX,QAAQpX,GAC3CmB,GAAS,IACXnB,EAAWzJ,IAAI,YAAalC,KAAK6kB,kBAAmB7kB,MACpDA,KAAK0jB,oBAAoB5W,GAAS,KAEtC,CAMA,wBAAA6X,CAAyBja,EAAaga,GACpCha,EAAYb,eAAe6a,OAASA,EACpC,IAAK,MAAMtW,KAAS1D,EAAY8D,oBAC9BxO,KAAK2kB,yBAAyBvW,EAAOsW,EAEzC,GAMFjB,GAAoBrZ,UAAY,CAC9BC,KAAM,CACJ,KAAcmH,YACd,KAAcC,cAEhBvU,KAAM,eACNge,SAAU,GAMZuI,GAAoBljB,eAAiB,CAEnC0jB,oBAAoB,EAEpBH,0BAA2B,IAE3BE,sBAAuB,KAEzB,IAAIkB,GAAqBzB,GCzMzB,MAAM0B,GAAmB,MAAMA,EAE7B,WAAArlB,CAAYuC,GACVrC,KAAKoD,UAAYf,EACjBrC,KAAKolB,MAAQ,EACbplB,KAAKqlB,WAAa,CACpB,CACA,IAAAvS,CAAK0B,GACHA,EAAU,IAAK2Q,EAAiB5kB,kBAAmBiU,GACnDxU,KAAKslB,cAAgB9Q,EAAQ+Q,uBAC7BvlB,KAAKwlB,QAAUhR,EAAQiR,mBAAqBjR,EAAQkR,iBACpD1lB,KAAK2lB,OAASnR,EAAQoR,eACxB,CAKA,UAAAjhB,GACO3E,KAAKoD,UAAUc,oBAGpBlE,KAAKolB,QACAplB,KAAK2lB,SAEV3lB,KAAKqlB,aACDrlB,KAAKqlB,WAAarlB,KAAKslB,gBACzBtlB,KAAKqlB,WAAa,EAClBrlB,KAAKokB,QAET,CAKA,GAAAA,GACE,MAAMyB,EAAkB7lB,KAAKoD,UAAUpC,QAAQ6kB,gBAC/C,IAAK,IAAI7nB,EAAI,EAAGA,EAAI6nB,EAAgB9hB,OAAQ/F,IAAK,CAC/C,MAAMgD,EAAU6kB,EAAgB7nB,GAC5BgD,EAAQ8kB,oBAAsB9kB,EAAQmD,UAAYnD,EAAQ+kB,UAAY,GAAK/lB,KAAKolB,MAAQpkB,EAAQ+kB,SAAW/lB,KAAKwlB,UAClHxkB,EAAQ+kB,UAAY,EACpB/kB,EAAQglB,SAEZ,CACF,CACA,OAAA/jB,GACEjC,KAAKoD,UAAY,IACnB,GAGF+hB,GAAiB/a,UAAY,CAC3BC,KAAM,CACJ,KAAcmH,YACd,KAAcC,cAEhBvU,KAAM,aAGRioB,GAAiB5kB,eAAiB,CAKhCqlB,iBAAiB,EAKjBH,kBAAmB,KAKnBC,iBAAkB,KAKlBH,uBAAwB,KAE1B,IAAIU,GAAkBd,G,oCC1EtB,MAAMe,GAAc,MAAMA,EAMxB,eAAIC,GACF,OAAOnmB,KAAKgB,QAAQC,OAAOklB,WAC7B,CACA,eAAIA,CAAY1d,GACdzI,KAAKgB,QAAQC,OAAOklB,YAAc1d,CACpC,CAEA,cAAI5H,GACF,OAAOb,KAAKgB,QAAQC,OAAOI,WAC7B,CACA,cAAIR,CAAW4H,GACbzI,KAAKgB,QAAQC,OAAOG,OAClBpB,KAAKgB,QAAQC,OAAON,MACpBX,KAAKgB,QAAQC,OAAOL,OACpB6H,EAEJ,CAKA,IAAAqK,CAAK0B,IACHA,EAAU,IACL0R,EAAY3lB,kBACZiU,IAEOnE,QACV,EAAA+V,GAAA,IAAY,MAAQ,yDACpB5R,EAAQwI,OAASxI,EAAQnE,MAE3BrQ,KAAK+H,OAAS,IAAIxF,GAAA,EAAU,EAAG,EAAGiS,EAAQ7T,MAAO6T,EAAQ5T,QACzDZ,KAAKgd,OAASxI,EAAQwI,QAAU,KAAW1W,MAAM+f,eACjDrmB,KAAKc,YAAc0T,EAAQ1T,UAC3Bd,KAAKgB,SAAU,EAAAmG,GAAA,GAAiBnH,KAAKgd,OAAQxI,GAC7CxU,KAAKyD,aAAe,IAAItB,GAAA,EAAa,CACnClC,cAAe,CAACD,KAAKgB,SACrBP,QAAS+T,EAAQ/T,MACjBN,QAAQ,IAEVH,KAAKgB,QAAQC,OAAOqlB,YAAc9R,EAAQqG,gBAAkB,EAC5D7a,KAAKa,WAAa2T,EAAQ3T,UAC5B,CAOA,MAAAO,CAAOmlB,EAAoBC,EAAqB3lB,GAC9Cb,KAAKgB,QAAQC,OAAOG,OAAOmlB,EAAoBC,EAAqB3lB,GACpEb,KAAK+H,OAAOpH,MAAQX,KAAKgB,QAAQ8C,MAAMnD,MACvCX,KAAK+H,OAAOnH,OAASZ,KAAKgB,QAAQ8C,MAAMlD,MAC1C,CAMA,OAAAqB,CAAQuS,GAAU,IACsB,kBAAZA,EAAwBA,EAAYA,GAASiS,aACrDzmB,KAAKgd,OAAO0J,YAC5B1mB,KAAKgd,OAAO0J,WAAW/H,YAAY3e,KAAKgd,OAE5C,GAGFkJ,GAAY9b,UAAY,CACtBC,KAAM,CACJ,KAAcmH,YACd,KAAcC,aACd,KAAcC,cAEhBxU,KAAM,OACNge,SAAU,GAGZgL,GAAY3lB,eAAiB,CAK3BI,MAAO,IAKPC,OAAQ,IAKRulB,aAAa,EAKbrlB,WAAW,GCzFb,MAAM6lB,GAAgB,CACpBxL,EACA0E,GACA2C,GDwFe0D,GCtFf7W,EACA4W,GACA7G,GACAJ,GACA,IACAkG,GACA9D,IAEIwF,GAAoB,CACxBnL,GACAtH,EACAxC,EACA3G,EACAwM,EACA+B,EACAT,EACAvP,E,0DCtCF,MAAMsd,EAA8B,IAAI9jB,IACxC,SAASoE,EAAiB6V,EAAQxI,GAChC,IAAKqS,EAAY/M,IAAIkD,GAAS,CAC5B,MAAMhc,EAAU,IAAI,IAAQ,CAC1BC,OAAQ,IAAI,IAAa,CACvBkD,SAAU6Y,KACPxI,MAGDsS,EAAY,KACZD,EAAYvgB,IAAI0W,KAAYhc,GAC9B6lB,EAAYvf,OAAO0V,EACrB,EAEFhc,EAAQqG,KAAK,UAAWyf,GACxB9lB,EAAQC,OAAOoG,KAAK,UAAWyf,GAC/BD,EAAYrf,IAAIwV,EAAQhc,EAC1B,CACA,OAAO6lB,EAAYvgB,IAAI0W,EACzB,C,iBChBA,SAAS+J,EAAoBC,EAAMC,EAAK5oB,GACtC,MAAMqc,GAASsM,GAAQ,GAAK,KAAO,IACnCC,EAAI5oB,MAAoB,IAAP2oB,GAAc,IAAMtM,EACrCuM,EAAI5oB,MAAa2oB,GAAQ,EAAI,KAAO,IAAMtM,EAC1CuM,EAAI5oB,MAAa2oB,GAAQ,GAAK,KAAO,IAAMtM,EAC3CuM,EAAI5oB,KAAYqc,CAClB,C,kDCZA,MAAMhP,EACJ,WAAA5L,GACEE,KAAKuT,YAAc,UACnBvT,KAAKknB,SAAW,gBAEhBlnB,KAAK8T,cAAgB,EACrB9T,KAAK2T,UAAY,EACjB3T,KAAKmnB,YAAa,EAClBnnB,KAAKwS,YAAc,EACnBxS,KAAKonB,gBAAkB,EAEvBpnB,KAAKuM,SAAW,KAChBvM,KAAKqnB,OAAS,IAChB,CACA,aAAIhf,GACF,OAAOrI,KAAK2L,WAAWsD,cACzB,CACA,SAAIwL,GACF,OAAOza,KAAK2L,WAAWqD,eACzB,CACA,KAAAiC,GACEjR,KAAK2L,WAAa,KAClB3L,KAAKgB,QAAU,KACfhB,KAAKuM,SAAW,KAChBvM,KAAKqnB,OAAS,KACdrnB,KAAK+L,OAAS,IAChB,E","sources":["webpack://taktwerk/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/container/utils/clearList.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/filters/Filter.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/utils/sayHello.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/utils/data/clean.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","webpack://taktwerk/./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"],"sourcesContent":["\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n         \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n//# sourceMappingURL=textureBit.mjs.map\n","import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexport { ensureAttributes };\n//# sourceMappingURL=ensureAttributes.mjs.map\n","import { STENCIL_MODES } from '../../shared/state/const.mjs';\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"not-equal\",\n    passOp: \"replace\"\n  },\n  stencilBack: {\n    compare: \"not-equal\",\n    passOp: \"replace\"\n  }\n};\n\nexport { GpuStencilModesToPixi };\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    /** unique id for this render target */\n    this.uid = uid(\"renderTarget\");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === \"number\") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new TextureSource({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   * @ignore\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new TextureSource({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: \"depth24plus-stencil8\",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0)\n        return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\nexport { RenderTarget };\n//# sourceMappingURL=RenderTarget.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection.mjs';\nimport { SystemRunner } from '../system/SystemRunner.mjs';\nimport { CanvasSource } from '../texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\nimport { isRenderingToScreen } from './isRenderingToScreen.mjs';\nimport { RenderTarget } from './RenderTarget.mjs';\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n    this.adaptor.prerender?.(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = CLEAR.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture.\n   *\n   * NOTE:\n   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n   *\n   * The following is not valid:\n   * @example\n   * const canvas = document.createElement('canvas')\n   * canvas.width = 200;\n   * canvas.height = 200;\n   *\n   * const ctx = canvas2.getContext('2d')!\n   * ctx.fillStyle = 'red'\n   * ctx.fillRect(0, 0, 200, 200);\n   *\n   * const texture = RenderTexture.create({\n   *   width: 200,\n   *   height: 200,\n   * })\n   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n   *\n   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n   *\n   * The best way to copy a canvas is to create a texture from it. Then render with that.\n   *\n   * Parsing in a RenderTarget canvas context (with a 2d context)\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource) {\n      renderTarget = new RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (CanvasSource.test(renderSurface.source.resource)) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n  resetState() {\n    this.renderTarget = null;\n    this.renderSurface = null;\n  }\n}\n\nexport { RenderTargetSystem };\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n","\"use strict\";\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\nexport { isRenderingToScreen };\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n","\"use strict\";\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\nexport { calculateProjection };\n//# sourceMappingURL=calculateProjection.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  updateRenderable() {\n  }\n  destroyRenderable() {\n  }\n  validateRenderable() {\n    return false;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"customRender\"\n};\n\nexport { CustomRenderPipe };\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n","\"use strict\";\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\nexport { executeInstructions };\n//# sourceMappingURL=executeInstructions.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../sprite/BatchableSprite.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    if (renderGroup.isCachedAsTexture) {\n      this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n    } else {\n      this._addRenderableDirect(renderGroup, instructionSet);\n    }\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    if (renderGroup.isCachedAsTexture) {\n      this._executeCacheAsTexture(renderGroup);\n    } else {\n      this._executeDirect(renderGroup);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _addRenderableDirect(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    if (renderGroup._batchableRenderGroup) {\n      BigPool.return(renderGroup._batchableRenderGroup);\n      renderGroup._batchableRenderGroup = null;\n    }\n    instructionSet.add(renderGroup);\n  }\n  _addRenderableCacheAsTexture(renderGroup, instructionSet) {\n    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));\n    batchableRenderGroup.renderable = renderGroup.root;\n    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n    batchableRenderGroup.texture = renderGroup.texture;\n    batchableRenderGroup.bounds = renderGroup._textureBounds;\n    instructionSet.add(renderGroup);\n    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n  }\n  _executeCacheAsTexture(renderGroup) {\n    if (renderGroup.textureNeedsUpdate) {\n      renderGroup.textureNeedsUpdate = false;\n      const worldTransformMatrix = tempMatrix.identity().translate(\n        -renderGroup._textureBounds.x,\n        -renderGroup._textureBounds.y\n      );\n      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n      this._renderer.globalUniforms.push({\n        worldTransformMatrix,\n        worldColor: 4294967295\n      });\n      executeInstructions(renderGroup, this._renderer.renderPipes);\n      this._renderer.renderTarget.finishRenderPass();\n      this._renderer.renderTarget.pop();\n      this._renderer.globalUniforms.pop();\n    }\n    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n  }\n  _executeDirect(renderGroup) {\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupPipe };\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n","\"use strict\";\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\nexport { clearList };\n//# sourceMappingURL=clearList.mjs.map\n","import { Container, UPDATE_VISIBLE, UPDATE_COLOR, UPDATE_BLEND } from '../Container.mjs';\nimport { clearList } from './clearList.mjs';\nimport { multiplyColors } from './multiplyColors.mjs';\n\n\"use strict\";\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = multiplyColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags |= container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    const renderable = container;\n    if (renderable.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(renderable);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & UPDATE_COLOR) {\n    container.groupColor = multiplyColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren };\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from './bounds/Bounds.mjs';\nimport { clearList } from './utils/clearList.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms.mjs';\nimport { validateRenderables } from './utils/validateRenderables.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    let originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    this._updateCachedRenderGroups(container.renderGroup, null);\n    this._updateRenderGroups(container.renderGroup);\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n    if (renderGroup.isCachedAsTexture) {\n      if (!renderGroup.updateCacheTexture)\n        return;\n      closestCacheAsTexture = renderGroup;\n    }\n    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {\n      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n    }\n    renderGroup.invalidateMatrices();\n    if (renderGroup.isCachedAsTexture) {\n      if (renderGroup.textureNeedsUpdate) {\n        const bounds = renderGroup.root.getLocalBounds();\n        bounds.ceil();\n        const lastTexture = renderGroup.texture;\n        if (renderGroup.texture) {\n          TexturePool.returnTexture(renderGroup.texture);\n        }\n        const renderer = this._renderer;\n        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n        renderGroup.texture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          resolution,\n          antialias\n        );\n        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());\n        renderGroup._textureBounds.copyFrom(bounds);\n        if (lastTexture !== renderGroup.texture) {\n          if (renderGroup.renderGroupParent) {\n            renderGroup.renderGroupParent.structureDidChange = true;\n          }\n        }\n      }\n    } else if (renderGroup.texture) {\n      TexturePool.returnTexture(renderGroup.texture);\n      renderGroup.texture = null;\n    }\n  }\n  _updateRenderGroups(renderGroup) {\n    const renderer = this._renderer;\n    const renderPipes = renderer.renderPipes;\n    renderGroup.runOnRender(renderer);\n    renderGroup.instructionSet.renderPipes = renderPipes;\n    if (!renderGroup.structureDidChange) {\n      validateRenderables(renderGroup, renderPipes);\n    } else {\n      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n    }\n    updateRenderGroupTransforms(renderGroup);\n    if (renderGroup.structureDidChange) {\n      renderGroup.structureDidChange = false;\n      this._buildInstructions(renderGroup, renderer);\n    } else {\n      this._updateRenderables(renderGroup);\n    }\n    renderGroup.childrenRenderablesToUpdate.index = 0;\n    renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)\n      return;\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n  }\n  _updateRenderables(renderGroup) {\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n    for (let i = 0; i < index; i++) {\n      const container = list[i];\n      if (container.didViewUpdate) {\n        renderGroup.updateRenderable(container);\n      }\n    }\n    clearList(list, index);\n  }\n  _buildInstructions(renderGroup, rendererOrPipes) {\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n    instructionSet.reset();\n    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n    const renderPipes = renderer.renderPipes;\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n    if (root.sortableChildren) {\n      root.sortChildren();\n    }\n    root.collectRenderablesWithEffects(instructionSet, renderer, null);\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupSystem };\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n","\"use strict\";\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list, index } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\nexport { validateRenderables };\n//# sourceMappingURL=validateRenderables.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from './BatchableSprite.mjs';\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._destroyRenderableBound = this.destroyRenderable.bind(this);\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_gpuSpriteHash\");\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    BigPool.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n    sprite.off(\"destroyed\", this._destroyRenderableBound);\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = BigPool.get(BatchableSprite);\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableSprite;\n    sprite.on(\"destroyed\", this._destroyRenderableBound);\n    return batchableSprite;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      BigPool.return(this._gpuSpriteHash[i]);\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexport { SpritePipe };\n//# sourceMappingURL=SpritePipe.mjs.map\n","import { ExtensionType, extensions } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { DefaultBatcher } from './DefaultBatcher.mjs';\n\n\"use strict\";\nconst _BatcherPipe = class _BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n    /** A record of all active batchers, keyed by their names */\n    this._activeBatches = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init?.(this);\n  }\n  static getBatcher(name) {\n    return new this._availableBatchers[name]();\n  }\n  buildStart(instructionSet) {\n    let batchers = this._batchersByInstructionSet[instructionSet.uid];\n    if (!batchers) {\n      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n      batchers.default || (batchers.default = new DefaultBatcher());\n    }\n    this._activeBatches = batchers;\n    this._activeBatch = this._activeBatches.default;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].begin();\n    }\n  }\n  addToBatch(batchableObject, instructionSet) {\n    if (this._activeBatch.name !== batchableObject.batcherName) {\n      this._activeBatch.break(instructionSet);\n      let batch = this._activeBatches[batchableObject.batcherName];\n      if (!batch) {\n        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n        batch.begin();\n      }\n      this._activeBatch = batch;\n    }\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    this._activeBatch.break(instructionSet);\n    const batches = this._activeBatches;\n    for (const i in batches) {\n      const batch = batches[i];\n      const geometry = batch.geometry;\n      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n    }\n  }\n  upload(instructionSet) {\n    const batchers = this._batchersByInstructionSet[instructionSet.uid];\n    for (const i in batchers) {\n      const batcher = batchers[i];\n      const geometry = batcher.geometry;\n      if (batcher.dirty) {\n        batcher.dirty = false;\n        geometry.buffers[0].update(batcher.attributeSize * 4);\n      }\n    }\n  }\n  execute(batch) {\n    if (batch.action === \"startBatch\") {\n      const batcher = batch.batcher;\n      const geometry = batcher.geometry;\n      const shader = batcher.shader;\n      this._adaptor.start(this, geometry, shader);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor = null;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].destroy();\n    }\n    this._activeBatches = null;\n  }\n};\n/** @ignore */\n_BatcherPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"batch\"\n};\n_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet BatcherPipe = _BatcherPipe;\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\nextensions.add(DefaultBatcher);\n\nexport { BatcherPipe };\n//# sourceMappingURL=BatcherPipe.mjs.map\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/**\n * The default filter settings\n * @static\n */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" },\n      uInverse: { value: options.inverse ? 1 : 0, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexport { MaskFilter };\n//# sourceMappingURL=MaskFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../renderers/types.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY),\n      inverse: false,\n      resolution: \"inherit\",\n      antialias: \"inherit\"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      maskContainer.collectRenderables(\n        instructionSet,\n        renderer,\n        null\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === RendererType.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"alphaMask\"\n};\n\nexport { AlphaMaskPipe };\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"colorMask\"\n};\n\nexport { ColorMaskPipe };\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    maskContainer.collectRenderables(\n      instructionSet,\n      renderer,\n      null\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexport { StencilMaskPipe };\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   * @ignore\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"background\",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\nexport { BackgroundSystem };\n//# sourceMappingURL=BackgroundSystem.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../../filters/FilterEffect.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nextensions.handle(ExtensionType.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.runners.prerender.add(this);\n  }\n  prerender() {\n    this._activeBlendMode = \"normal\";\n    this._isAdvanced = false;\n  }\n  /**\n   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n   * @param renderable - The renderable we are adding to the instruction set\n   * @param blendMode - The blend mode of the renderable\n   * @param instructionSet - The instruction set we are adding to\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced)\n        this._renderableList.push(renderable);\n      return;\n    }\n    this._activeBlendMode = blendMode;\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced) {\n      this._beginAdvancedBlendMode(instructionSet);\n      this._renderableList.push(renderable);\n    }\n  }\n  _beginAdvancedBlendMode(instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      renderables: [],\n      filterEffect,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   * @ignore\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   * @ignore\n   */\n  buildEnd(instructionSet) {\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"blendMode\"\n};\n\nexport { BlendModePipe };\n//# sourceMappingURL=BlendModePipe.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst imageTypes = {\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  webp: \"image/webp\"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container || options instanceof Texture) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Will return a HTML Image of the target\n   * @param options - The options for creating the image, or the target to extract\n   * @returns - HTML Image of the target\n   */\n  async image(options) {\n    const image = new Image();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Will return a base64 encoded string of this target. It works by calling\n   * `Extract.canvas` and then running toDataURL on that.\n   * @param options - The options for creating the image, or the target to extract\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns - A Canvas element with the texture rendered on.\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy(true);\n    return canvas;\n  }\n  /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns - One-dimensional array containing the pixel data of the entire texture\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container) {\n      texture.destroy(true);\n    }\n    return pixelInfo;\n  }\n  /**\n   * Will return a texture of the target\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns - A texture of the target\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Will extract a HTMLImage of the target and download it\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement(\"a\");\n    link.download = options.filename ?? \"image.png\";\n    link.href = canvas.toDataURL(\"image/png\");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * @param options - The options for logging the image, or the target to log\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      \"font-size: 1px;\",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      \"background-size: contain;\"\n    ].join(\" \");\n    console.log(\"%c \", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"extract\"\n};\n/** Default options for creating an image. */\n_ExtractSystem.defaultImageOptions = {\n  /** The format of the image. */\n  format: \"png\",\n  /** The quality of the image. */\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\nexport { ExtractSystem };\n//# sourceMappingURL=ExtractSystem.mjs.map\n","import { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nclass RenderTexture extends Texture {\n  static create(options) {\n    return new RenderTexture({\n      source: new TextureSource(options)\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\nexport { RenderTexture };\n//# sourceMappingURL=RenderTexture.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { RenderTexture } from '../texture/RenderTexture.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * A Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your container is complicated and needs to be reused multiple times.\n   * @param {GenerateTextureOptions | Container} options - Generate texture options.\n   * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n   * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n   * @param {number} [options.resolution] - The resolution of the texture being generated.\n   *        if no region is specified, defaults to the local bounds of the container.\n   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n   * @returns a shiny new texture of the container passed in\n   */\n  generateTexture(options) {\n    if (options instanceof Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGenerator\"\n};\n\nexport { GenerateTextureSystem };\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../../maths/point/Point.mjs';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix(),\n      worldColor: 4294967295,\n      offset: new Point()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    color32BitToUniform(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === RendererType.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get globalUniformData() {\n    return this._currentGlobalUniformData;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup({\n      uProjectionMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uWorldTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"globalUniforms\"\n};\n\nexport { GlobalUniformSystem };\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../ticker/Ticker.mjs';\n\n\"use strict\";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    this._offset = 0;\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration, useOffset = true) {\n    const id = uid++;\n    let offset = 0;\n    if (useOffset) {\n      this._offset += 1e3;\n      offset = this._offset;\n    }\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      offset,\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.offset - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    Ticker.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"scheduler\",\n  priority: 0\n};\n\nexport { SchedulerSystem };\n//# sourceMappingURL=SchedulerSystem.mjs.map\n","import { DOMAdapter } from '../environment/adapter.mjs';\nimport { VERSION } from './const.mjs';\n\n\"use strict\";\nlet saidHello = false;\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      \"background: #E72264; padding:5px 0;\",\n      \"background: #6CA2EA; padding:5px 0;\",\n      \"background: #B5D33D; padding:5px 0;\",\n      \"background: #FED23F; padding:5px 0;\",\n      \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n      \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\nexport { sayHello };\n//# sourceMappingURL=sayHello.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { sayHello } from '../../../../utils/sayHello.mjs';\nimport { RendererType } from '../../types.mjs';\n\n\"use strict\";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === RendererType.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"hello\",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\nexport { HelloSystem };\n//# sourceMappingURL=HelloSystem.mjs.map\n","\"use strict\";\nfunction cleanHash(hash) {\n  let clean = false;\n  for (const i in hash) {\n    if (hash[i] == void 0) {\n      clean = true;\n      break;\n    }\n  }\n  if (!clean)\n    return hash;\n  const cleanHash2 = /* @__PURE__ */ Object.create(null);\n  for (const i in hash) {\n    const value = hash[i];\n    if (value) {\n      cleanHash2[i] = value;\n    }\n  }\n  return cleanHash2;\n}\nfunction cleanArray(arr) {\n  let offset = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] == void 0) {\n      offset++;\n    } else {\n      arr[i - offset] = arr[i];\n    }\n  }\n  arr.length -= offset;\n  return arr;\n}\n\nexport { cleanArray, cleanHash };\n//# sourceMappingURL=clean.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { cleanHash, cleanArray } from '../../../../utils/data/clean.mjs';\n\n\"use strict\";\nlet renderableGCTick = 0;\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /**\n   * Creates a new RenderableGCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of renderables being tracked for garbage collection */\n    this._managedRenderables = [];\n    /** Array of hash objects being tracked for cleanup */\n    this._managedHashes = [];\n    /** Array of arrays being tracked for cleanup */\n    this._managedArrays = [];\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options for the renderer\n   */\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    this._frequency = options.renderableGCFrequency;\n    this.enabled = options.renderableGCActive;\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => this.run(),\n        this._frequency,\n        false\n      );\n      this._hashHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const hash of this._managedHashes) {\n            hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n          }\n        },\n        this._frequency\n      );\n      this._arrayHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const array of this._managedArrays) {\n            cleanArray(array.context[array.hash]);\n          }\n        },\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._renderer.scheduler.cancel(this._hashHandler);\n      this._renderer.scheduler.cancel(this._arrayHandler);\n    }\n  }\n  /**\n   * Adds a hash table to be managed by the garbage collector.\n   * @param context - The object containing the hash table\n   * @param hash - The property name of the hash table\n   */\n  addManagedHash(context, hash) {\n    this._managedHashes.push({ context, hash });\n  }\n  /**\n   * Adds an array to be managed by the garbage collector.\n   * @param context - The object containing the array\n   * @param hash - The property name of the array\n   */\n  addManagedArray(context, hash) {\n    this._managedArrays.push({ context, hash });\n  }\n  /**\n   * Updates the GC timestamp and tracking before rendering.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({\n    container\n  }) {\n    this._now = performance.now();\n    container.renderGroup.gcTick = renderableGCTick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /**\n   * Starts tracking a renderable for garbage collection.\n   * @param renderable - The renderable to track\n   */\n  addRenderable(renderable) {\n    if (!this.enabled)\n      return;\n    if (renderable._lastUsed === -1) {\n      this._managedRenderables.push(renderable);\n      renderable.once(\"destroyed\", this._removeRenderable, this);\n    }\n    renderable._lastUsed = this._now;\n  }\n  /**\n   * Performs garbage collection by cleaning up unused renderables.\n   * Removes renderables that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = this._now;\n    const managedRenderables = this._managedRenderables;\n    const renderPipes = this._renderer.renderPipes;\n    let offset = 0;\n    for (let i = 0; i < managedRenderables.length; i++) {\n      const renderable = managedRenderables[i];\n      if (renderable === null) {\n        offset++;\n        continue;\n      }\n      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n      const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n      if ((renderGroup?.gcTick ?? 0) === currentTick) {\n        renderable._lastUsed = now;\n      }\n      if (now - renderable._lastUsed > this.maxUnusedTime) {\n        if (!renderable.destroyed) {\n          const rp = renderPipes;\n          if (renderGroup)\n            renderGroup.structureDidChange = true;\n          rp[renderable.renderPipeId].destroyRenderable(renderable);\n        }\n        renderable._lastUsed = -1;\n        offset++;\n        renderable.off(\"destroyed\", this._removeRenderable, this);\n      } else {\n        managedRenderables[i - offset] = renderable;\n      }\n    }\n    managedRenderables.length -= offset;\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._renderer = null;\n    this._managedRenderables.length = 0;\n    this._managedHashes.length = 0;\n    this._managedArrays.length = 0;\n  }\n  /**\n   * Removes a renderable from being tracked when it's destroyed.\n   * @param renderable - The renderable to stop tracking\n   */\n  _removeRenderable(renderable) {\n    const index = this._managedRenderables.indexOf(renderable);\n    if (index >= 0) {\n      renderable.off(\"destroyed\", this._removeRenderable, this);\n      this._managedRenderables[index] = null;\n    }\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n};\n/**\n * Extension metadata for registering this system with the renderer.\n * @ignore\n */\n_RenderableGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"renderableGC\",\n  priority: 0\n};\n/**\n * Default configuration options for the garbage collection system.\n * These can be overridden when initializing the renderer.\n */\n_RenderableGCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  renderableGCActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  renderableGCMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\nexport { RenderableGCSystem };\n//# sourceMappingURL=RenderableGCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n  }\n  init(options) {\n    options = { ..._TextureGCSystem.defaultOptions, ...options };\n    this.checkCountMax = options.textureGCCheckCountMax;\n    this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n    this.active = options.textureGCActive;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    if (!this._renderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (!this.active)\n      return;\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const managedTextures = this._renderer.texture.managedTextures;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {\n        texture._touched = -1;\n        texture.unload();\n      }\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGC\"\n};\n/** default options for the TextureGCSystem */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystem.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\nexport { TextureGCSystem };\n//# sourceMappingURL=TextureGCSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { RenderTarget } from '../renderTarget/RenderTarget.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\n\n\"use strict\";\nconst _ViewSystem = class _ViewSystem {\n  /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n   * @member {boolean}\n   */\n  get autoDensity() {\n    return this.texture.source.autoDensity;\n  }\n  set autoDensity(value) {\n    this.texture.source.autoDensity = value;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      deprecation(v8_0_0, \"ViewSystem.view has been renamed to ViewSystem.canvas\");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle(0, 0, options.width, options.height);\n    this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = getCanvasTexture(this.canvas, options);\n    this.renderTarget = new RenderTarget({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or \"false\".\n   * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n   */\n  destroy(options = false) {\n    const removeView = typeof options === \"boolean\" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"view\",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\nexport { ViewSystem };\n//# sourceMappingURL=ViewSystem.mjs.map\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe.mjs';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe.mjs';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem.mjs';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe.mjs';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks.mjs';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe.mjs';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe.mjs';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe.mjs';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe.mjs';\nimport { BackgroundSystem } from '../background/BackgroundSystem.mjs';\nimport { BlendModePipe } from '../blendModes/BlendModePipe.mjs';\nimport { ExtractSystem } from '../extract/ExtractSystem.mjs';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem.mjs';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem.mjs';\nimport { SchedulerSystem } from '../SchedulerSystem.mjs';\nimport { HelloSystem } from '../startup/HelloSystem.mjs';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem.mjs';\nimport { TextureGCSystem } from '../texture/TextureGCSystem.mjs';\nimport { ViewSystem } from '../view/ViewSystem.mjs';\n\n\"use strict\";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem,\n  RendererInitHook,\n  RenderableGCSystem,\n  SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\nexport { SharedRenderPipes, SharedSystems };\n//# sourceMappingURL=SharedSystems.mjs.map\n","import { CanvasSource } from '../sources/CanvasSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst canvasCache = /* @__PURE__ */ new Map();\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new Texture({\n      source: new CanvasSource({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once(\"destroy\", onDestroy);\n    texture.source.once(\"destroy\", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\nexport { getCanvasTexture, hasCachedCanvasTexture };\n//# sourceMappingURL=getCanvasTexture.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n"],"names":["localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","textureBit","fragment","textureBitGl","ensureAttributes","geometry","extractedData","i","attributes","attribute","attributeData","format","offset","instance","buffers","tempStride","tempStart","j","buffer","uid","stride","start","ensureStartAndStride","GpuStencilModesToPixi","NONE","DISABLED","stencilWriteMask","stencilReadMask","RENDERING_MASK_ADD","stencilFront","compare","passOp","stencilBack","RENDERING_MASK_REMOVE","MASK_ACTIVE","INVERSE_MASK_ACTIVE","_RenderTarget","constructor","descriptor","this","colorTextures","dirtyId","isRoot","_size","Float32Array","_managedColorTextures","defaultOptions","stencil","depth","push","width","height","resolution","antialias","map","texture","source","colorSource","colorTexture","resize","_resolution","on","onSourceResize","depthStencilTexture","ensureDepthStencilTexture","size","pixelWidth","pixelHeight","autoGenerateMipmaps","mipLevelCount","skipColorTexture","forEach","destroy","off","RenderTarget","RenderTargetSystem","renderer","rootViewPort","Rectangle","viewport","onRenderTargetChange","SystemRunner","projectionMatrix","Matrix","defaultClearColor","_renderSurfaceToRenderTargetHash","Map","_gpuRenderTargetHash","Object","create","_renderTargetStack","_renderer","renderableGC","addManagedHash","finishRenderPass","adaptor","renderTarget","renderStart","target","clear","clearColor","frame","length","copyFrom","rootRenderTarget","renderingToScreen","resource","globalThis","HTMLCanvasElement","document","body","contains","isRenderingToScreen","prerender","postrender","bind","renderSurface","getRenderTarget","didChange","gpuRenderTarget","getGpuRenderTarget","resizeGpuRenderTarget","Texture","x","y","pm","flipY","sign","identity","a","d","tx","ty","calculateProjection","startRenderPass","emit","ALL","contextChange","pop","currentRenderTargetData","isTexture","get","_initRenderTarget","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","Math","min","ensureDepthStencil","key","CanvasSource","test","getCanvasTexture","TextureSource","once","delete","destroyGpuRenderTarget","set","initGpuRenderTarget","resetState","blendModeIds","normal","add","multiply","screen","overlay","erase","max","_State","data","blendMode","polygonOffset","blend","depthMask","value","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","state","default2d","State","CustomRenderPipe","updateRenderable","destroyRenderable","validateRenderable","addRenderable","container","instructionSet","renderPipes","batch","break","execute","isRenderable","render","extension","type","WebGLPipes","WebGPUPipes","CanvasPipes","executeInstructions","renderGroup","instructions","instructionSize","instruction","renderPipeId","tempMatrix","RenderGroupPipe","addRenderGroup","isCachedAsTexture","_addRenderableCacheAsTexture","_addRenderableDirect","_executeCacheAsTexture","_executeDirect","_batchableRenderGroup","return","batchableRenderGroup","BatchableSprite","renderable","root","transform","relativeGroupTransform","bounds","_textureBounds","addToBatch","textureNeedsUpdate","worldTransformMatrix","translate","globalUniforms","worldColor","_batcher","updateElement","update","inverseParentTextureTransform","worldColorAlpha","clearList","list","index","tempContainer","Container","UPDATE_BLEND_COLOR_VISIBLE","updateRenderGroupTransforms","updateChildRenderGroups","worldAlpha","renderGroupParent","worldTransform","appendFrom","multiplyColors","groupColor","groupAlpha","localTransform","localColor","localAlpha","updateRenderGroupTransform","childrenToUpdate","updateTick","renderGroupDepth","Number","childrenAtDepth","child","parentRenderGroup","relativeRenderGroupDepth","updateTransformAndChildren","renderGroupChildren","updateFlags","updateLocalTransform","parent","_updateFlags","updateColorBlendVisibility","children","structureDidChange","groupColorAlpha","groupBlendMode","localBlendMode","globalDisplayStatus","localDisplayStatus","RenderGroupSystem","originalLocalTransform","_updateCachedRenderGroups","_updateRenderGroups","uniformBatch","renderEnd","closestCacheAsTexture","updateCacheTexture","_parentCacheAsTextureRenderGroup","invalidateMatrices","getLocalBounds","ceil","lastTexture","TexturePool","returnTexture","textureOptions","view","getOptimalTexture","Bounds","runOnRender","childrenRenderablesToUpdate","rebuildRequired","validateRenderables","_buildInstructions","_updateRenderables","upload","didViewUpdate","rendererOrPipes","reset","buildStart","colorMask","sortableChildren","sortChildren","collectRenderablesWithEffects","buildEnd","WebGLSystem","WebGPUSystem","CanvasSystem","SpritePipe","_gpuSpriteHash","_destroyRenderableBound","sprite","gpuSprite","_getGpuSprite","_updateBatchableSprite","checkAndUpdateTexture","_texture","batchableSprite","visualBounds","_initGPUSprite","groupTransform","roundPixels","_roundPixels","_BatcherPipe","_batchersByInstructionSet","_activeBatches","_adaptor","init","getBatcher","_availableBatchers","batchers","default","DefaultBatcher","_activeBatch","begin","batchableObject","batcherName","batches","indexBuffer","setDataWithSize","indexSize","attributeBuffer","float32View","attributeSize","batcher","dirty","action","shader","BatcherPipe","handleByMap","Batcher","_Filter","Shader","options","super","enabled","_state","padding","blendRequired","clipToViewport","addResource","apply","filterManager","input","output","clearMode","applyFilter","from","gpu","gl","rest","gpuProgram","glProgram","GpuProgram","GlProgram","Filter","MaskFilter","textureMatrix","TextureMatrix","filterUniforms","UniformGroup","uFilterMatrix","uMaskClamp","uClampFrame","uAlpha","uInverse","inverse","entryPoint","resources","uMaskTexture","_textureMatrix","uniforms","calculateSpriteMatrix","prepend","mapCoord","tempBounds","AlphaMaskEffect","FilterEffect","filters","Sprite","EMPTY","AlphaMaskPipe","_activeMaskStage","mask","maskedContainer","_maskOptions","canBundle","renderMaskToTexture","maskContainer","includeInBuild","collectRenderables","_maskedContainer","renderMask","filterEffect","measurable","getGlobalBounds","colorTextureSource","filterTexture","minX","minY","maskData","WEBGL","filter","ColorMaskPipe","_colorStack","_colorStackIndex","_currentColor","_container","colorStack","currentColor","_mask","setMask","StencilMaskPipe","_maskStackHash","_maskHash","WeakMap","_a","effect","setBlendMode","has","instructionsStart","instructionsLength","renderTargetUid","maskStackIndex","setStencilMode","STENCIL","_BackgroundSystem","clearBeforeRender","_backgroundColor","Color","color","alpha","background","backgroundColor","backgroundAlpha","setAlpha","setValue","colorRgba","toArray","priority","BackgroundSystem","BLEND_MODE_FILTERS","handle","BlendMode","Error","ref","BlendModePipe","_isAdvanced","_filterHash","runners","_activeBlendMode","_endAdvancedBlendMode","_beginAdvancedBlendMode","_renderableList","warn","renderables","imageTypes","png","jpg","webp","_ExtractSystem","_normalizeOptions","defaults","image","Image","src","base64","defaultImageOptions","quality","canvas","toBlob","Promise","resolve","reject","blob","reader","FileReader","onload","result","onerror","readAsDataURL","toDataURL","convertToBlob","generateCanvas","textureGenerator","generateTexture","pixels","pixelInfo","getPixels","download","link","createElement","filename","href","appendChild","click","removeChild","log","console","style","join","ExtractSystem","RenderTexture","tempRect","noColor","GenerateTextureSystem","textureSourceOptions","Array","isArray","shared","region","copyTo","rectangle","updateMipmaps","GlobalUniformSystem","_stackIndex","_globalUniformDataStack","_uniformsPool","_activeUniforms","_bindGroupPool","_activeBindGroups","currentGlobalUniformData","projectionData","Point","globalUniformData","bindGroup","uniformGroup","_createUniforms","uProjectionMatrix","uResolution","uWorldTransformMatrix","uWorldColorAlpha","getUniformBindGroup","BindGroup","setResource","_currentGlobalUniformData","isStatic","SchedulerSystem","_tasks","_offset","Ticker","system","_update","repeat","func","duration","useOffset","id","performance","now","last","cancel","splice","task","elapsed","remove","saidHello","HelloSystem","hello","context","webGLVersion","getNavigator","userAgent","toLowerCase","indexOf","args","sayHello","cleanHash","hash","clean","cleanHash2","cleanArray","arr","renderableGCTick","_RenderableGCSystem","_managedRenderables","_managedHashes","_managedArrays","maxUnusedTime","renderableGCMaxUnusedTime","_frequency","renderableGCFrequency","renderableGCActive","_handler","scheduler","run","_hashHandler","_arrayHandler","array","addManagedArray","_now","gcTick","_updateInstructionGCTick","_lastUsed","_removeRenderable","managedRenderables","currentTick","destroyed","rp","RenderableGCSystem","_TextureGCSystem","count","checkCount","checkCountMax","textureGCCheckCountMax","maxIdle","textureGCAMaxIdle","textureGCMaxIdle","active","textureGCActive","managedTextures","autoGarbageCollect","_touched","unload","TextureGCSystem","_ViewSystem","autoDensity","deprecation","createCanvas","transparent","desiredScreenWidth","desiredScreenHeight","removeView","parentNode","SharedSystems","SharedRenderPipes","canvasCache","onDestroy","color32BitToUniform","abgr","out","topology","packAsQuad","_attributeStart","_batch"],"sourceRoot":""}